### SOLICITAÇÃO:

  Verifique se nós criarmos uma estrutura diferente se funcionaria 
    melhor:\
    1- Tabela de estoque atual: Todo registro em movimentação de 
    estoque alteraria o estoque atual da seguinte forma:\\
    Adição/remoção/alteração da MovimentaçãoEstoque seria feito 
    tambem no estoque atual, não é recalcular tudo, é pegar o saldo
   
    atual e alterar.\
    Adicionar campo em estoque atual com a data e hora da ultima 
    atualização.\
    A cada 1 minuto pegar as 10 movimentações mais antigas e 
    recalcular elas através das movimentações de estoque (Não sei 
  se 
    a qtd ou o tempo são coerentes).\
    Dessa forma toda alteração em Movimentação de estoque seria 
    atualizado o estoque atual com um fallback através do 
  recalculo.\
    \
    2- Criar tabela de movimentacao prevista com entrada_prevista e
   
    saida_prevista:\
    Toda alteração em PreSeparacaoItem, ProgramacaoProducao ou 
    Separacao, deverá ataulizar a movimentacao prevista sendo 
    PreSeparacaoItem ou Separacao atualizando a saida prevista e a 
    ProgramacaoProducao atualizar a entrada prevista.\
    \
    3- Est.D+7 / Ruptura 7d  será atualizado:\
    A cada alteração da movimentacao prevista recalculando o 
  estoque 
    dos próximos 7 dias e pegando o menor estoque dos próximos 7 
    dias, pois é onde pode alterar o dia e o menor estoque dos 
    próximos 7 dias.\
    A cada alteração de MovimentacaoEstoque alterando diretamente o
   
    Est.D+7 sem recalcular o estoque dos próximos 7 dias, pois o 
  dia 
    de menor estoque permanecerá o mesmo, visto que o que alterou 
  foi
     o estoque atual, refletindo igualmente em todos os 7 dias.\
    \
    3- Em SaldoEstoque e no workspace de montagem seria feito uma 
    query direta no estoque atual e saida prevista / entrada 
  prevista
     apenas do que houver na tela.\
    \
    Com isso veremos a performance de uma forma melhorada ao invés 
  de
     ter que pesquisar todas as movimentações, todas as separações 
  e 
    pré separações.\
    \
    Se fizer sentido esse "fallback" no estoque atual a cada 1 
    minuto, podemos avaliar o impacto na performance de fazer 
  tambem 
    com a entrada prevista, saida prevista e menor estoque dos 
    próximos 7 dias.\
    \
    Pelo menos com isso acredito que quase que "modularizamos" as 
    movimentações de estoque, views etc, e com isso caso seja 
    necessario usar cache, usariamos de maneira especifica pois 
  dessa
     maneira generalista acaba sendo necessario usar agendadores e 
    com isso perde-se completamente a precisão do estoque.


### PERGUNTAS CLAUDE:


Vou analisar cuidadosamente sua proposta de reestruturação do
  sistema de estoque. Antes de criar o prompt completo, preciso
  esclarecer alguns pontos para garantir precisão total:

  Questões para Esclarecimento:

  1. Sobre a Tabela de Estoque Atual:

  - Qual modelo atual gerencia o estoque hoje? É EstoqueAtual ou
  existe dentro de outro modelo?
  - O "fallback" de recálculo a cada 1 minuto seria uma task
  assíncrona (Celery) ou um job agendado?
  - Quando você menciona "10 movimentações mais antigas", seria
  ordenado por qual campo exatamente?

  2. Sobre Movimentação Prevista:

  - As entradas previstas viriam APENAS de ProgramacaoProducao?
  - As saídas previstas viriam de PreSeparacaoItem E Separacao?
  Como seria tratado quando um item migra de PreSeparacao para
  Separacao?
  - Precisamos de um campo para distinguir se a movimentação
  prevista já foi efetivada?

  3. Sobre o Cálculo de Ruptura (Est.D+7):

  - Esse valor seria armazenado em qual tabela/campo?
  - O "menor estoque dos próximos 7 dias" consideraria dias úteis
  ou corridos?
  - Precisamos armazenar também QUAL dia terá o menor estoque?

  4. Sobre Performance e Índices:

  - Quais são os volumes aproximados de dados?
    - Quantos produtos?
    - Quantas movimentações/dia?
    - Quantas pré-separações ativas?

  5. Sobre Triggers e Eventos:

  - Prefere usar triggers do PostgreSQL ou eventos do SQLAlchemy?
  - Existe alguma preferência sobre uso de transações para garantir
   consistência?

  6. Sobre a Estrutura Atual:

  Deixe-me verificar os modelos existentes para entender melhor:

● Search(pattern: "class.*EstoqueAtual|class.*MovimentacaoEstoque|c
        lass.*ProgramacaoProducao", glob: "**/*.py")
  ⎿  Found 3 files (ctrl+r to expand)

● Read(app/estoque/models.py)
  ⎿  Read 100 lines (ctrl+r to expand)

● Read(app/producao/models.py)
  ⎿  Read 80 lines (ctrl+r to expand)

● Search(pattern: "class.*EstoqueAtual|class.*SaldoEstoque", glob:
        "**/*.py")
  ⎿  Found 2 files (ctrl+r to expand)

● Read(app/estoque/models.py)
  ⎿  Read 200 lines (ctrl+r to expand)

● Agora vou verificar a estrutura das tabelas PreSeparacaoItem e
  Separacao:

● Search(pattern: "class PreSeparacaoItem|class Separacao", glob:
        "app/**/*.py", output_mode: "content")
  ⎿  Found 17 lines (ctrl+r to expand)

● Baseado na minha análise, vou criar um prompt completo e
  estruturado. Mas antes, preciso confirmar alguns pontos
  importantes:

  Pontos que Preciso Confirmar:

  1. Sistema de Cache Híbrido Existente

  Encontrei referências a EstoqueProjecaoCache e models_hibrido.py.
   Você quer:
  - a) Substituir completamente esse sistema híbrido pelo novo?
  - b) Manter o híbrido e criar o novo em paralelo?
  - c) Evoluir o sistema híbrido existente?

  2. Sobre o Fallback de 1 Minuto

  Você mencionou "10 movimentações mais antigas". Isso seria:
  - a) As 10 movimentações com campo criado_em mais antigo?
  - b) As 10 movimentações com maior diferença entre criado_em e
  atualizado_em?
  - c) As 10 movimentações não verificadas (precisa campo novo
  verificado_em)?

  3. Dados de Ruptura/Est.D+7

  Onde armazenar o "menor estoque dos próximos 7 dias":
  - a) Na nova tabela EstoqueAtual como campo menor_estoque_d7?
  - b) Em uma tabela separada ProjecaoRuptura?
  - c) Como campo calculado em tempo real?

  4. Tratamento de Unificação de Códigos

  O sistema atual já tem UnificacaoCodigos. Na nova estrutura:
  - a) Manter usando
  UnificacaoCodigos.get_todos_codigos_relacionados()?
  - b) Criar tabela desnormalizada com códigos já unificados?
  - c) Ignorar unificação na nova estrutura?

  5. Transições de Status

  Quando um item vai de PreSeparacaoItem → Separacao:
  - a) Manter ambas as movimentações previstas?
  - b) Marcar a de PreSeparacao como "efetivada"?
  - c) Deletar a movimentação prevista de PreSeparacao?

  6. Performance Esperada

  Para dimensionar corretamente:
  - Quantos produtos ativos aproximadamente?
  - Quantas movimentações por dia?
  - Quantos usuários simultâneos no workspace?

  Com essas respostas, posso criar um prompt extremamente preciso
  que garanta a implementação correta da estrutura que você
  precisa, incluindo todos os campos, índices, triggers e
  mecanismos de sincronização necessários.


### MINHAS RESPOSTAS:

  > 1- Sim, é o estoque atual.\
  Não sei a diferença de task assincrona e job agendado, eu pensei 
  em fazer a cada 1 minuto, isso já é claro o suficiente para poder
   pensar na melhor maneira.\
  Seria utilizado um campo "atualizado_em" que deverá ser gravado 
  no momento da atualização.\
  \
  2- Entrada prevista viria apenas de ProgramacaoProducao\
  Saida prevista viria apenas de PreSeparacaoItem ou Separacao.\
  Caso uma PreSeparacao confirme pra Separacao não é necessario 
  ataulizar visto que as qtds e data se mantem.\
  Caso seja mais facil para generalizar "qualquer alteração" pode 
  incluir a confirmação de PreSeparacaoItem para Separacao, caso 
  não seja feito dessa maneira pode manter após qualquer alteração 
  de data, cancelamento, exclusão apenas de 1 item na 
  PreSeparacaoItem, alteração do EmbarqueItem.erro_validacao quando
   se tornar = None (Nesse caso significa que o faturamento foi 
  importado e vinculado a uma separação, fazendo que com isso a 
  movimentacao de estoque seja gravada e excluindo os erros de 
  validação do EmbarqueItem, dessa forma deverá subtrair as qtds da
   Separacao.separacao_lote_id do EmbarqueItem.separacao_lote_id 
  onde EmbarqueItem.erro_validacao se tornar=None)\
  \
  3- Estou propondo criar uma estrutura do zero portanto seria 
  criado.\
  \
  4- 600 produtos cadastrados, 500 movimentações por dia, em torno 
  de 50 preseparações e 50 separações ativas, com média de 15 itens
   por preseparação/separação.\
  \
  5- Prefiro usar algo que a consulta de estoque/projeção se torne 
  rapida e traga dados atualizados reais, dados atrasados de 5 
  segundos não são toleraveis, a estrutura precisa ser muito bem 
  desenvolvida para garantir performance e que os dados sejam dados
   atualizados daquele momento e não de dados de X segundos atras.\
  \
  \
  1- Substituir completamente esse sistema pelo novo.\\
  2- 10 movimentações com atualizado_em mais antigo (Eu não tenho 
  idéia de performance, não sei se é possivel 50 por minuto ou 5 a 
  cda 10 minutos, apenas temos que ter idéia da proporção dos 
  dados, são 600 produtos e 500 movimentações por dia)\
  3- Já respondido\
  4- Considerar a Unificação dos códigos para 
  GRAVAR/ATUALIZAR/EXCLUIR os dados e não apenas na hora da 
  consulta\
  5- Pense, se saiu de PreSeparacaoItem e foi pra Separacao ou é 
  -PreSeparacaoItem e + Separacao ou não altera visto que voce 
  apenas efetivou algo com as mesma informações chave (codigo, data
   e qtd)


### RESPOSTA CLAUDE:

 Thinking…

  Agora tenho todas as informações necessárias para criar um prompt
   completo e estruturado. O usuário quer:

  1. Substituir completamente o sistema híbrido existente
  2. Criar uma estrutura de estoque com:
    - EstoqueAtual: tabela persistente com estoque atual e última 
  atualização
    - MovimentacaoPrevista: entrada_prevista e saida_prevista
    - Sistema de fallback recalculando 10 movimentações mais 
  antigas a cada minuto
    - Cálculo de ruptura D+7 armazenado
  3. Performance crítica - dados em tempo real, sem atraso
  4. Considerar unificação de códigos em todas operações
  5. 600 produtos, 500 movimentações/dia, 50 pré-separações e 50 
  separações ativas

  Vou criar um prompt bem estruturado que force a implementação 
  completa e correta.

● Perfeito! Agora tenho todas as informações necessárias. Vou criar
   um prompt extremamente detalhado e estruturado que garantirá a
  implementação correta e completa da nova estrutura de estoque:

PROMPT COMPLETO PARA IMPLEMENTAÇÃO DA NOVA ESTRUTURA DE ESTOQUE

  # IMPLEMENTAÇÃO COMPLETA - NOVO SISTEMA DE PROJEÇÃO E CÁLCULO DE
  ESTOQUE

  ## CONTEXTO E REQUISITOS CRÍTICOS
  Você deve criar uma nova estrutura de estoque que SUBSTITUA
  COMPLETAMENTE o sistema híbrido existente (models_hibrido.py), 
  com foco em PERFORMANCE e DADOS EM TEMPO REAL. 

  ### VOLUMES DE DADOS:
  - 600 produtos cadastrados
  - 500 movimentações/dia
  - 50 pré-separações ativas (média 15 itens cada = 750 registros)
  - 50 separações ativas (média 15 itens cada = 750 registros)

  ### REQUISITO CRÍTICO DE PERFORMANCE:
  - Consultas devem retornar em < 100ms
  - ZERO tolerância para dados defasados (máximo 1 segundo)
  - Todas as alterações devem ser refletidas IMEDIATAMENTE

  ## ESTRUTURA COMPLETA A IMPLEMENTAR:

  ### 1. TABELA: EstoqueAtual
  ```python
  class EstoqueAtual(db.Model):
      __tablename__ = 'estoque_atual'

      # Chave primária
      cod_produto = db.Column(db.String(50), primary_key=True,
  index=True)
      nome_produto = db.Column(db.String(200), nullable=False)

      # Saldo atual em tempo real
      saldo_atual = db.Column(db.Numeric(15, 3), nullable=False,
  default=0)

      # Controle de atualização para fallback
      atualizado_em = db.Column(db.DateTime, nullable=False,
  default=agora_brasil, onupdate=agora_brasil)
      ultima_verificacao = db.Column(db.DateTime, nullable=True)  #
   Para controle do recálculo
      hash_movimentacao = db.Column(db.String(64), nullable=True)
  # Hash da última movimentação processada

      # Campos de projeção
      menor_estoque_d7 = db.Column(db.Numeric(15, 3),
  nullable=True)  # Menor estoque próximos 7 dias
      dia_ruptura = db.Column(db.Date, nullable=True)  # Data
  prevista de ruptura

      # Auditoria
      criado_em = db.Column(db.DateTime, default=agora_brasil)
      criado_por = db.Column(db.String(100), nullable=True)

      # Índices
      __table_args__ = (
          db.Index('idx_estoque_atual_atualizado',
  'atualizado_em'),
          db.Index('idx_estoque_atual_verificacao',
  'ultima_verificacao'),
      )

  2. TABELA: MovimentacaoPrevista

  class MovimentacaoPrevista(db.Model):
      __tablename__ = 'movimentacao_prevista'

      id = db.Column(db.Integer, primary_key=True)

      # Identificação
      cod_produto = db.Column(db.String(50), nullable=False,
  index=True)
      data_prevista = db.Column(db.Date, nullable=False,
  index=True)

      # Quantidades (apenas uma será preenchida por registro)
      entrada_prevista = db.Column(db.Numeric(15, 3),
  nullable=True, default=0)
      saida_prevista = db.Column(db.Numeric(15, 3), nullable=True,
  default=0)

      # Origem da movimentação
      tipo_origem = db.Column(db.String(30), nullable=False)  # 
  'PRODUCAO', 'PRE_SEPARACAO', 'SEPARACAO'
      origem_id = db.Column(db.String(100), nullable=False)  # ID 
  do registro origem

      # Status
      efetivada = db.Column(db.Boolean, default=False, index=True)
      data_efetivacao = db.Column(db.DateTime, nullable=True)

      # Controle
      atualizado_em = db.Column(db.DateTime, default=agora_brasil,
  onupdate=agora_brasil)
      hash_origem = db.Column(db.String(64), nullable=True)  # Hash
   para detectar mudanças

      # Índices compostos para performance
      __table_args__ = (
          db.Index('idx_mov_prevista_produto_data', 'cod_produto',
  'data_prevista'),
          db.Index('idx_mov_prevista_origem', 'tipo_origem',
  'origem_id'),
          db.Index('idx_mov_prevista_efetivada', 'efetivada',
  'data_prevista'),
          db.UniqueConstraint('tipo_origem', 'origem_id',
  'cod_produto', name='uq_mov_prevista_origem'),
      )

  3. SERVIÇO: ServicoEstoqueAtual

  class ServicoEstoqueAtual:
      """Serviço principal para gestão de estoque atual com 
  triggers automáticos"""

      @staticmethod
      def atualizar_por_movimentacao(movimentacao: 
  MovimentacaoEstoque, operacao='insert'):
          """
          Atualiza EstoqueAtual quando MovimentacaoEstoque é 
  alterada
          DEVE ser chamado por signal/trigger do SQLAlchemy
          """
          # Implementar lógica considerando UnificacaoCodigos

      @staticmethod
      def atualizar_por_prevista(tipo_origem, origem_id, 
  cod_produto, data, qtd, tipo='saida'):
          """
          Atualiza MovimentacaoPrevista e recalcula 
  menor_estoque_d7
          Chamado quando PreSeparacaoItem, Separacao ou 
  ProgramacaoProducao mudam
          """

      @staticmethod
      def processar_fallback():
          """
          Job agendado para recalcular 10 movimentações mais 
  antigas
          Executar a cada 60 segundos via APScheduler ou Celery 
  Beat
          """

      @staticmethod
      def calcular_ruptura_d7(cod_produto):
          """
          Calcula menor estoque dos próximos 7 dias
          Atualiza EstoqueAtual.menor_estoque_d7 e dia_ruptura
          """

  4. TRIGGERS SQLAlchemy (em app/init.py ou models.py)

  from sqlalchemy import event

  # Trigger para MovimentacaoEstoque
  @event.listens_for(MovimentacaoEstoque, 'after_insert')
  def movimentacao_after_insert(mapper, connection, target):
      # Atualizar EstoqueAtual imediatamente

  @event.listens_for(MovimentacaoEstoque, 'after_update')
  def movimentacao_after_update(mapper, connection, target):
      # Atualizar EstoqueAtual com diferença

  # Trigger para PreSeparacaoItem
  @event.listens_for(PreSeparacaoItem, 'after_insert')
  @event.listens_for(PreSeparacaoItem, 'after_update')
  @event.listens_for(PreSeparacaoItem, 'after_delete')
  def preseparacao_changed(mapper, connection, target):
      # Atualizar MovimentacaoPrevista

  # Trigger para Separacao
  @event.listens_for(Separacao, 'after_insert')
  @event.listens_for(Separacao, 'after_update')
  @event.listens_for(Separacao, 'after_delete')
  def separacao_changed(mapper, connection, target):
      # Atualizar MovimentacaoPrevista

  # Trigger para ProgramacaoProducao
  @event.listens_for(ProgramacaoProducao, 'after_insert')
  @event.listens_for(ProgramacaoProducao, 'after_update')
  @event.listens_for(ProgramacaoProducao, 'after_delete')
  def producao_changed(mapper, connection, target):
      # Atualizar MovimentacaoPrevista (entrada)

  # Trigger especial para EmbarqueItem
  @event.listens_for(EmbarqueItem, 'after_update')
  def embarque_item_validacao_changed(mapper, connection, target):
      # Se erro_validacao mudou para None, processar movimentação

  5. JOB AGENDADO (APScheduler)

  # Em app/__init__.py ou scheduler.py
  from apscheduler.schedulers.background import BackgroundScheduler

  scheduler = BackgroundScheduler()

  def job_recalculo_estoque():
      """Recalcula 10 movimentações mais antigas a cada minuto"""
      with app.app_context():
          ServicoEstoqueAtual.processar_fallback()

  scheduler.add_job(
      func=job_recalculo_estoque,
      trigger="interval",
      seconds=60,
      id='recalculo_estoque',
      replace_existing=True
  )
  scheduler.start()

  6. MIGRAÇÃO DE DADOS

  def migrar_dados_existentes():
      """
      Script para migração inicial dos dados
      1. Criar EstoqueAtual baseado em MovimentacaoEstoque
      2. Popular MovimentacaoPrevista de PreSeparacaoItem e 
  Separacao
      3. Popular MovimentacaoPrevista de ProgramacaoProducao
      4. Calcular menor_estoque_d7 para todos produtos
      """

  7. APIS DE CONSULTA OTIMIZADAS

  class ServicoConsultaEstoque:
      @staticmethod
      def obter_estoque_workspace(cod_produtos: list):
          """
          Consulta otimizada para workspace
          - Join direto com EstoqueAtual (não calcula, apenas lê)
          - Join com MovimentacaoPrevista para próximos 7 dias
          - Retorno < 100ms garantido
          """

      @staticmethod
      def obter_projecao_produto(cod_produto, dias=28):
          """
          Projeção completa de um produto
          - EstoqueAtual.saldo_atual como D0
          - MovimentacaoPrevista agrupada por dia
          - Cálculo incremental dia a dia
          """

  CHECKLIST DE IMPLEMENTAÇÃO OBRIGATÓRIA:

  Fase 1 - Estrutura Base

  - Criar migration para as 2 novas tabelas
  - Implementar models EstoqueAtual e MovimentacaoPrevista
  - Adicionar todos os índices necessários
  - Criar constraints de unicidade

  Fase 2 - Triggers e Eventos

  - Implementar todos os event listeners SQLAlchemy
  - Considerar UnificacaoCodigos em TODAS operações
  - Implementar lógica de hash para detectar mudanças
  - Garantir transações ACID

  Fase 3 - Serviços

  - Implementar ServicoEstoqueAtual completo
  - Implementar cálculo de ruptura D+7
  - Implementar job de fallback
  - Criar APIs de consulta otimizadas

  Fase 4 - Migração

  - Script de migração de dados existentes
  - Validação de integridade pós-migração
  - Backup antes da migração

  Fase 5 - Performance

  - Testes de carga com volumes reais
  - EXPLAIN ANALYZE nas queries principais
  - Ajuste de índices se necessário
  - Cache de consultas frequentes (se necessário)

  REGRAS CRÍTICAS:

  1. SEMPRE considerar
  UnificacaoCodigos.get_todos_codigos_relacionados()
  2. NUNCA recalcular tudo - sempre incremental
  3. Usar transações para garantir consistência
  4. Log de TODAS operações de atualização
  5. Tratamento de erros com rollback
  6. Testes unitários para cada trigger

  ARQUIVOS A CRIAR/MODIFICAR:

  1. app/estoque/models_novo.py - Novos modelos
  2. app/estoque/services/estoque_atual.py - Serviços
  3. app/estoque/triggers.py - Event listeners
  4. app/estoque/jobs.py - Jobs agendados
  5. migrations/xxx_nova_estrutura_estoque.py - Migration
  6. app/estoque/api_novo.py - APIs otimizadas
  7. scripts/migrar_estoque.py - Script migração
  8. tests/test_estoque_novo.py - Testes

  RESULTADO ESPERADO:

  - Consultas < 100ms para workspace com 50 produtos
  - Atualização instantânea em mudanças
  - Zero dados defasados
  - Fallback automático garantindo precisão
  - Sistema resiliente e escalável

  Este prompt está completo e estruturado para garantir que você
  implemente corretamente todo o sistema. Ele inclui:

  1. **Estrutura exata das tabelas** com todos os campos
  necessários
  2. **Triggers específicos** para cada operação
  3. **Lógica de negócio** detalhada
  4. **Sistema de fallback** com job agendado
  5. **Consideração de unificação de códigos** em todas operações
  6. **APIs otimizadas** para consulta rápida
  7. **Checklist de implementação** para não esquecer nada
  8. **Tratamento de casos especiais** como
  EmbarqueItem.erro_validacao

  Posso começar a implementação ou você gostaria de ajustar algo no
   prompt antes?

### MINHA RESPOSTA: 

 1- voce coloca "atualizado_em", "ultima_verificacao" e 
  "hash_movimentacao", pra que 3 campos? Quantos campos voce usará 
  e qual a utilidade de 3?\
  criado_por e criado_em é desnecessario.\
  \
  2- tipo_origem e origem_id, efetivada, data_efetivacao, como voce
   usará isso? Pra que isso se é uma tabela cumulativa?\
  \
  3- Isso deverá ocorrer a cada alteração em MovimentacaoPrevista 
  ou EstoqueAtual.\
  Como voce estava planejando disparar esse calculo?\
  \
  4- Se erro_validacao mudou para None, cancelar a movimentacao da 
  Separacao.separacao_lote_id do EmbarqueItem.separacao_lote_id do 
  Embarque_Item.erro_validacao alterado para None.\
  \
  Fase 1 - a tabela EstoqueAtual já existe, acredito ser melhor 
  criar um novo nome ou voce irá usar a existente?\
  \
  \
  ### 1- Me responda as perguntas acima.\
  ### 2- Altere o prompt e me reenvie.

  RESPOSTA CLAUDE: 

  Excelentes observações! Vou responder cada ponto e depois enviar
  o prompt revisado:

  RESPOSTAS:

  1. Campos em EstoqueAtual:

  Você está certo, 3 campos é redundante. Precisamos apenas:
  - atualizado_em: marca quando o saldo foi alterado (para o job
  pegar os 10 mais antigos)
  - ultima_verificacao REMOVIDO (desnecessário)
  - hash_movimentacao REMOVIDO (desnecessário)
  - criado_em e criado_por REMOVIDO (desnecessário)

  2. Campos em MovimentacaoPrevista:

  Você tem razão sobre ser cumulativa. Simplificando:
  - tipo_origem e origem_id REMOVIDO (desnecessário para tabela
  cumulativa)
  - efetivada e data_efetivacao REMOVIDO (não faz sentido em tabela
   cumulativa)
  - Manter apenas: cod_produto, data_prevista, entrada_prevista,
  saida_prevista

  3. Cálculo de ruptura D+7:

  Será disparado:
  - Por trigger após INSERT/UPDATE/DELETE em MovimentacaoPrevista
  - Por trigger após UPDATE em EstoqueAtual (quando saldo_atual
  muda)
  - Executado inline no mesmo trigger, não como job separado

  4. EmbarqueItem.erro_validacao:

  Entendi: quando erro_validacao muda para None, devemos
  CANCELAR/REMOVER a movimentação prevista da Separacao
  correspondente.

  5. Tabela EstoqueAtual existente:

  Vou verificar a estrutura existente e usar nome diferente:
  EstoqueTempoReal

### PROMPT FINAL CLAUDE:

PROMPT REVISADO E OTIMIZADO:


Você é um desenvolvedor sênior responsável por implementar um sistema de estoque em tempo real com projeção futura.

Pense profundamente e valide cada camada antes de gerar qualquer código. A execução será feita em etapas obrigatórias:

Etapa 1: Liste os modelos envolvidos e os campos necessários
Etapa 2: Liste todos os triggers, causas e efeitos esperados
Etapa 3: Liste os riscos de recursividade ou inconsistência e como serão evitados
Etapa 4: Só após validação completa, inicie a geração de cada arquivo em ordem: models, services, triggers, job, API

Regras obrigatórias:
- Sempre use `UnificacaoCodigos` na gravação e leitura
- Nunca use hash ou campos extras se não forem usados
- Toda operação que afeta EstoqueTempoReal ou MovimentacaoPrevista deve recalcular D+7
- Evite triggers que se chamem entre si recursivamente
- O tempo de resposta para consulta em API deve ser < 100ms

# IMPLEMENTAÇÃO COMPLETA - NOVO SISTEMA DE PROJEÇÃO E CÁLCULO DE
  ESTOQUE

  ## CONTEXTO E REQUISITOS CRÍTICOS
  Você deve criar uma nova estrutura de estoque que SUBSTITUA
  COMPLETAMENTE o sistema híbrido existente (models_hibrido.py), 
  com foco em PERFORMANCE e DADOS EM TEMPO REAL. 

  ### VOLUMES DE DADOS:
  - 600 produtos cadastrados
  - 500 movimentações/dia
  - 50 pré-separações ativas (média 15 itens cada = 750 registros)
  - 50 separações ativas (média 15 itens cada = 750 registros)

  ### REQUISITO CRÍTICO DE PERFORMANCE:
  - Consultas devem retornar em < 100ms
  - ZERO tolerância para dados defasados (máximo 1 segundo)
  - Todas as alterações devem ser refletidas IMEDIATAMENTE


  ## ESTRUTURA COMPLETA:

  ### 1. TABELA: EstoqueTempoReal (nova tabela)
  ```python
  class EstoqueTempoReal(db.Model):
      __tablename__ = 'estoque_tempo_real'

      # Chave primária
      cod_produto = db.Column(db.String(50), primary_key=True,
  index=True)
      nome_produto = db.Column(db.String(200), nullable=False)

      # Saldo atual em tempo real
      saldo_atual = db.Column(db.Numeric(15, 3), nullable=False,
  default=0)

      # Controle para job de fallback (recalcular 10 mais antigos)
      atualizado_em = db.Column(db.DateTime, nullable=False,
  default=agora_brasil, onupdate=agora_brasil, index=True)

      # Projeção calculada
      menor_estoque_d7 = db.Column(db.Numeric(15, 3),
  nullable=True)
      dia_ruptura = db.Column(db.Date, nullable=True)

      __table_args__ = (
          db.Index('idx_estoque_tempo_real_atualizado',
  'atualizado_em'),
      )

  2. TABELA: MovimentacaoPrevista (cumulativa simples)

  class MovimentacaoPrevista(db.Model):
      __tablename__ = 'movimentacao_prevista'

      id = db.Column(db.Integer, primary_key=True)

      # Identificação
      cod_produto = db.Column(db.String(50), nullable=False,
  index=True)
      data_prevista = db.Column(db.Date, nullable=False,
  index=True)

      # Quantidades CUMULATIVAS (soma de todas as origens)
      entrada_prevista = db.Column(db.Numeric(15, 3),
  nullable=False, default=0)
      saida_prevista = db.Column(db.Numeric(15, 3), nullable=False,
   default=0)

      # Índice composto para consultas rápidas
      __table_args__ = (
          db.Index('idx_mov_prevista_produto_data', 'cod_produto',
  'data_prevista'),
          db.UniqueConstraint('cod_produto', 'data_prevista',
  name='uq_produto_data'),
      )

  3. SERVIÇO PRINCIPAL

  class ServicoEstoqueTempoReal:

      @staticmethod
      def processar_movimentacao_estoque(movimentacao, 
  operacao='insert', qtd_anterior=None):
          """
          Chamado por trigger quando MovimentacaoEstoque muda
          - INSERT: soma/subtrai do saldo_atual
          - UPDATE: ajusta pela diferença
          - DELETE: reverte a movimentação
          """
          # Obter códigos unificados
          codigos = UnificacaoCodigos.get_todos_codigos_relacionado
  s(movimentacao.cod_produto)

          for codigo in codigos:
              estoque =
  EstoqueTempoReal.query.filter_by(cod_produto=codigo).first()
              if not estoque:
                  estoque = EstoqueTempoReal(cod_produto=codigo,
  nome_produto=movimentacao.nome_produto)

              # Atualizar saldo baseado no tipo e operação
              if operacao == 'insert':
                  delta = movimentacao.qtd_movimentacao if
  movimentacao.tipo_movimentacao == 'ENTRADA' else
  -movimentacao.qtd_movimentacao
              elif operacao == 'update':
                  delta_novo = movimentacao.qtd_movimentacao if
  movimentacao.tipo_movimentacao == 'ENTRADA' else
  -movimentacao.qtd_movimentacao
                  delta_anterior = qtd_anterior if
  movimentacao.tipo_movimentacao == 'ENTRADA' else -qtd_anterior
                  delta = delta_novo - delta_anterior
              else:  # delete
                  delta = -movimentacao.qtd_movimentacao if
  movimentacao.tipo_movimentacao == 'ENTRADA' else
  movimentacao.qtd_movimentacao

              estoque.saldo_atual += delta
              estoque.atualizado_em = agora_brasil()
              db.session.add(estoque)

      @staticmethod
      def atualizar_movimentacao_prevista(cod_produto, data, 
  qtd_entrada=0, qtd_saida=0):
          """
          Atualiza ou cria registro em MovimentacaoPrevista
          Sempre SOMA às quantidades existentes (cumulativo)
          """
          # Considerar unificação
          codigos =
  UnificacaoCodigos.get_todos_codigos_relacionados(cod_produto)

          for codigo in codigos:
              mov = MovimentacaoPrevista.query.filter_by(
                  cod_produto=codigo,
                  data_prevista=data
              ).first()

              if not mov:
                  mov = MovimentacaoPrevista(
                      cod_produto=codigo,
                      data_prevista=data,
                      entrada_prevista=0,
                      saida_prevista=0
                  )

              mov.entrada_prevista += qtd_entrada
              mov.saida_prevista += qtd_saida

              # Se zerou, deletar registro
              if mov.entrada_prevista <= 0 and mov.saida_prevista
  <= 0:
                  db.session.delete(mov)
              else:
                  db.session.add(mov)

          # Recalcular ruptura após atualizar
          ServicoEstoqueTempoReal.calcular_ruptura_d7(cod_produto)

      @staticmethod
      def calcular_ruptura_d7(cod_produto):
          """
          Calcula menor estoque dos próximos 7 dias
          Chamado após QUALQUER alteração em MovimentacaoPrevista 
  ou EstoqueTempoReal
          """
          estoque =
  EstoqueTempoReal.query.filter_by(cod_produto=cod_produto).first()
          if not estoque:
              return

          saldo = float(estoque.saldo_atual)
          menor_saldo = saldo
          dia_ruptura = None
          hoje = date.today()

          # Buscar movimentações dos próximos 7 dias
          movimentacoes = MovimentacaoPrevista.query.filter(
              MovimentacaoPrevista.cod_produto == cod_produto,
              MovimentacaoPrevista.data_prevista >= hoje,
              MovimentacaoPrevista.data_prevista <= hoje +
  timedelta(days=7)
          ).order_by(MovimentacaoPrevista.data_prevista).all()

          for mov in movimentacoes:
              saldo = saldo + float(mov.entrada_prevista) -
  float(mov.saida_prevista)
              if saldo < menor_saldo:
                  menor_saldo = saldo
                  if saldo < 0 and not dia_ruptura:
                      dia_ruptura = mov.data_prevista

          estoque.menor_estoque_d7 = menor_saldo
          estoque.dia_ruptura = dia_ruptura
          db.session.add(estoque)

      @staticmethod
      def processar_fallback():
          """
          Job que roda a cada 60 segundos
          Pega 10 produtos com atualizado_em mais antigo e 
  recalcula do zero
          """
          produtos = EstoqueTempoReal.query.order_by(
              EstoqueTempoReal.atualizado_em.asc()
          ).limit(10).all()

          for produto in produtos:
              # Recalcular saldo do zero baseado em 
  MovimentacaoEstoque
              saldo = 0
              movs = MovimentacaoEstoque.query.filter_by(
                  cod_produto=produto.cod_produto,
                  ativo=True
              ).all()

              for mov in movs:
                  if mov.tipo_movimentacao == 'ENTRADA':
                      saldo += float(mov.qtd_movimentacao)
                  else:
                      saldo -= float(mov.qtd_movimentacao)

              produto.saldo_atual = saldo
              produto.atualizado_em = agora_brasil()
              db.session.add(produto)

          db.session.commit()

  4. TRIGGERS SQLALCHEMY

  # Em app/estoque/triggers.py

  from sqlalchemy import event
  from datetime import date

  # TRIGGER: MovimentacaoEstoque -> EstoqueTempoReal
  @event.listens_for(MovimentacaoEstoque, 'after_insert')
  def mov_estoque_insert(mapper, connection, target):

  ServicoEstoqueTempoReal.processar_movimentacao_estoque(target,
  'insert')

  @event.listens_for(MovimentacaoEstoque, 'after_update')
  def mov_estoque_update(mapper, connection, target):
      # Pegar valor anterior do histórico do SQLAlchemy
      qtd_anterior =
  db.inspect(target).attrs.qtd_movimentacao.history.deleted[0] if
  db.inspect(target).attrs.qtd_movimentacao.history.deleted else
  target.qtd_movimentacao

  ServicoEstoqueTempoReal.processar_movimentacao_estoque(target,
  'update', qtd_anterior)

  @event.listens_for(MovimentacaoEstoque, 'after_delete')
  def mov_estoque_delete(mapper, connection, target):

  ServicoEstoqueTempoReal.processar_movimentacao_estoque(target,
  'delete')

  # TRIGGER: PreSeparacaoItem -> MovimentacaoPrevista (saída)
  @event.listens_for(PreSeparacaoItem, 'after_insert')
  def presep_insert(mapper, connection, target):
      if target.data_expedicao_editada:
          ServicoEstoqueTempoReal.atualizar_movimentacao_prevista(
              target.cod_produto,
              target.data_expedicao_editada,
              qtd_saida=float(target.qtd_selecionada_usuario)
          )

  @event.listens_for(PreSeparacaoItem, 'after_update')
  def presep_update(mapper, connection, target):
      # Reverter quantidade anterior e adicionar nova
      hist = db.inspect(target).attrs

      # Reverter anterior se havia
      if hist.data_expedicao_editada.history.deleted:
          data_anterior =
  hist.data_expedicao_editada.history.deleted[0]
          qtd_anterior =
  hist.qtd_selecionada_usuario.history.deleted[0] if
  hist.qtd_selecionada_usuario.history.deleted else 0
          if data_anterior and qtd_anterior:

  ServicoEstoqueTempoReal.atualizar_movimentacao_prevista(
                  target.cod_produto,
                  data_anterior,
                  qtd_saida=-float(qtd_anterior)
              )

      # Adicionar nova
      if target.data_expedicao_editada:
          ServicoEstoqueTempoReal.atualizar_movimentacao_prevista(
              target.cod_produto,
              target.data_expedicao_editada,
              qtd_saida=float(target.qtd_selecionada_usuario)
          )

  @event.listens_for(PreSeparacaoItem, 'after_delete')
  def presep_delete(mapper, connection, target):
      if target.data_expedicao_editada:
          ServicoEstoqueTempoReal.atualizar_movimentacao_prevista(
              target.cod_produto,
              target.data_expedicao_editada,
              qtd_saida=-float(target.qtd_selecionada_usuario)
          )

  # TRIGGER: Separacao -> MovimentacaoPrevista (saída)
  @event.listens_for(Separacao, 'after_insert')
  def sep_insert(mapper, connection, target):
      if target.expedicao and target.qtd_saldo:
          ServicoEstoqueTempoReal.atualizar_movimentacao_prevista(
              target.cod_produto,
              target.expedicao,
              qtd_saida=float(target.qtd_saldo)
          )

  # ... similar para update e delete

  # TRIGGER: ProgramacaoProducao -> MovimentacaoPrevista (entrada)
  @event.listens_for(ProgramacaoProducao, 'after_insert')
  def prod_insert(mapper, connection, target):
      ServicoEstoqueTempoReal.atualizar_movimentacao_prevista(
          target.cod_produto,
          target.data_programacao,
          qtd_entrada=float(target.qtd_programada)
      )

  # ... similar para update e delete

  # TRIGGER ESPECIAL: EmbarqueItem.erro_validacao -> None (cancela 
  Separacao)
  @event.listens_for(EmbarqueItem, 'after_update')
  def embarque_validacao(mapper, connection, target):
      hist = db.inspect(target).attrs.erro_validacao.history

      # Se erro_validacao mudou para None (antes tinha erro, agora 
  não tem)
      if hist.deleted and hist.deleted[0] is not None and
  target.erro_validacao is None:
          # Buscar separacao correspondente
          separacao = Separacao.query.filter_by(
              separacao_lote_id=target.separacao_lote_id
          ).first()

          if separacao and separacao.expedicao:
              # CANCELAR movimentação prevista desta separação

  ServicoEstoqueTempoReal.atualizar_movimentacao_prevista(
                  separacao.cod_produto,
                  separacao.expedicao,
                  qtd_saida=-float(separacao.qtd_saldo)
              )

  # TRIGGER: Após alterar MovimentacaoPrevista -> Recalcular 
  ruptura
  @event.listens_for(MovimentacaoPrevista, 'after_insert')
  @event.listens_for(MovimentacaoPrevista, 'after_update')
  @event.listens_for(MovimentacaoPrevista, 'after_delete')
  def mov_prevista_changed(mapper, connection, target):

  ServicoEstoqueTempoReal.calcular_ruptura_d7(target.cod_produto)

  # TRIGGER: Após alterar EstoqueTempoReal.saldo_atual -> 
  Recalcular ruptura
  @event.listens_for(EstoqueTempoReal, 'after_update')
  def estoque_changed(mapper, connection, target):
      if
  db.inspect(target).attrs.saldo_atual.history.has_changes():

  ServicoEstoqueTempoReal.calcular_ruptura_d7(target.cod_produto)

  5. JOB DE FALLBACK

  # Em app/__init__.py
  from apscheduler.schedulers.background import BackgroundScheduler

  scheduler = BackgroundScheduler()
  scheduler.add_job(
      func=ServicoEstoqueTempoReal.processar_fallback,
      trigger="interval",
      seconds=60,
      id='fallback_estoque',
      replace_existing=True
  )
  scheduler.start()

  6. API OTIMIZADA PARA CONSULTA

  class APIEstoqueTempoReal:
      @staticmethod
      def consultar_workspace(cod_produtos: list):
          """
          Consulta direta nas tabelas pré-calculadas
          Retorno garantido < 100ms
          """
          # Query simples e direta
          estoques = EstoqueTempoReal.query.filter(
              EstoqueTempoReal.cod_produto.in_(cod_produtos)
          ).all()

          resultado = []
          for est in estoques:
              # Buscar saídas/entradas dos próximos dias se 
  necessário
              movs = MovimentacaoPrevista.query.filter(
                  MovimentacaoPrevista.cod_produto ==
  est.cod_produto,
                  MovimentacaoPrevista.data_prevista >=
  date.today(),
                  MovimentacaoPrevista.data_prevista <=
  date.today() + timedelta(days=7)
              ).all()

              resultado.append({
                  'cod_produto': est.cod_produto,
                  'nome_produto': est.nome_produto,
                  'estoque_atual': float(est.saldo_atual),
                  'menor_estoque_d7': float(est.menor_estoque_d7)
  if est.menor_estoque_d7 else None,
                  'dia_ruptura': est.dia_ruptura,
                  'movimentacoes_previstas': [
                      {
                          'data': mov.data_prevista,
                          'entrada': float(mov.entrada_prevista),
                          'saida': float(mov.saida_prevista)
                      } for mov in movs
                  ]
              })

          return resultado

  ARQUIVOS A CRIAR:

  1. app/estoque/models_tempo_real.py - Novos modelos
  2. app/estoque/services/estoque_tempo_real.py - Serviço principal
  3. app/estoque/triggers_tempo_real.py - Todos os triggers
  4. app/estoque/api_tempo_real.py - APIs de consulta
  5. migrations/xxx_estoque_tempo_real.py - Migration
  6. scripts/migrar_para_tempo_real.py - Migração de dados

  CHECKLIST SIMPLIFICADO:

  - Criar 2 tabelas novas (EstoqueTempoReal e MovimentacaoPrevista)
  - Implementar triggers para TODAS as tabelas origem
  - Implementar job de fallback (60 segundos)
  - Sempre considerar UnificacaoCodigos
  - Migrar dados existentes
  - Testar performance < 100ms


  psql $DATABASE_URL -f migrations/add_subcategorias_palletizacao.sql
  python atualizar_movimentacoes_previstas.py

Preciso criar algumas criações e exportações de relatórios em excel:

Crie um botão no Dashboard da carteira chamado "Relatórios" que:
Abra um Modal com 4 botões e 1 filtro de data "de" e "até".
Esse filtro deverá ter um botão "aplicar" e um botão "limpar".
Ao aplicar, grave no modal em qlqr lugar as datas solicitadas para servir de referencia para o usuario.
Os botões deverão:
1- Exportar todas as pré separações com status "CRIADO" e "RECOMPOSTO".
2- Exportar todas as separações fazendo Join com Pedido para extrair o status
3- Exportar Carteira de pedidos
4- Exportar a Carteira de Pedidos da forma que:
A- Traga todos os campos de app/carteira/routes/detalhes_api.py em 1 unica linha por cod_produto/num_pedido excluindo apenas os campos de "endereço de entrega", os campos de qtd, valor, peso e pallet deverão trazer 2 vezes, a 1a vez deverá trazer considerando apenas o pedido e a outra deverá trazer abatendo os valor de pré separação e separação.
B- Embaixo de cada linha do pedido (cod_produto/num_pedido) traga cada linha da pré separação correspondente aquela linha do pedido onde deverá repetir os campos de cliente e preencher com as informações da pré separação abaixo dos campos "semelhantes" de detalhes (exemplo cod_produto embaixo de cod_produto), os valores deverão ser preenchidos abaixo dos valor abatidos do pedido.
C- Embaixo de todas as Pré separações por do num_pedido/cod_produto, trazer as separações com a mesma lógica da pré separação.

O intuito é ter um relatório que traga uma posição completa e atual da carteira de pedidos para o comercial de maneira que não tenha varios buracos no relatório e que eu consiga analisar as qtds e datas de expedicao por produto/num_pedido/separação ou pre_separacao

Na tela de "Dashboard de Produção" tem um botão de "Relatórios Produção" que não funciona.
O que eu quero é que esse botão gere 1 arquivo excel com 2 abas, sendo em 1 aba um relatório de estoque atualizado e na outra aba um relatório de MovimentaçõesPrevistas