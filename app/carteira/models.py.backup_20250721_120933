# Modelos do m√≥dulo carteira
# FaturamentoPorProduto foi movido para app/faturamento/models.py

# TODO: Implementar modelos espec√≠ficos do m√≥dulo carteira conforme necess√°rio 

from app import db
from datetime import datetime, timedelta
from app.utils.timezone import agora_brasil
from sqlalchemy import func, and_, or_, Index
import logging
import hashlib

logger = logging.getLogger(__name__)

class CarteiraPrincipal(db.Model):
    """
    Modelo principal da carteira de pedidos - Baseado no arquivo 1
    Cont√©m todos os 91 campos identificados + proje√ß√£o D0-D28
    """
    __tablename__ = 'carteira_principal'

    id = db.Column(db.Integer, primary_key=True)
    
    # üÜî CHAVES PRIM√ÅRIAS DE NEG√ìCIO
    num_pedido = db.Column(db.String(50), nullable=False, index=True)  # Chave principal
    cod_produto = db.Column(db.String(50), nullable=False, index=True)  # Chave produto
    
    # üìã DADOS DO PEDIDO
    pedido_cliente = db.Column(db.String(100), nullable=True)  # Pedido de Compra do Cliente
    data_pedido = db.Column(db.Date, nullable=True, index=True)  # Data de cria√ß√£o
    data_atual_pedido = db.Column(db.Date, nullable=True)  # Data da √∫ltima altera√ß√£o
    status_pedido = db.Column(db.String(50), nullable=True, index=True)  # Cancelado, Pedido de venda, Cota√ß√£o
    
    # üë• DADOS DO CLIENTE
    cnpj_cpf = db.Column(db.String(20), nullable=False, index=True)  # CNPJ do cliente
    raz_social = db.Column(db.String(255), nullable=True)  # Raz√£o Social
    raz_social_red = db.Column(db.String(100), nullable=True)  # Nome reduzido
    municipio = db.Column(db.String(100), nullable=True)  # Cidade do cliente
    estado = db.Column(db.String(2), nullable=True)  # UF do cliente
    vendedor = db.Column(db.String(100), nullable=True, index=True)  # Vendedor respons√°vel
    equipe_vendas = db.Column(db.String(100), nullable=True)  # Equipe de vendas
    
    # üì¶ DADOS DO PRODUTO
    nome_produto = db.Column(db.String(255), nullable=False)  # Descri√ß√£o do produto
    unid_medida_produto = db.Column(db.String(20), nullable=True)  # Unidade de medida
    embalagem_produto = db.Column(db.String(100), nullable=True)  # Categoria
    materia_prima_produto = db.Column(db.String(100), nullable=True)  # Sub categoria  
    categoria_produto = db.Column(db.String(100), nullable=True)  # Sub sub categoria
    
    # üìä QUANTIDADES E VALORES
    qtd_produto_pedido = db.Column(db.Numeric(15, 3), nullable=False)  # Quantidade original
    qtd_saldo_produto_pedido = db.Column(db.Numeric(15, 3), nullable=False)  # Saldo a faturar
    qtd_cancelada_produto_pedido = db.Column(db.Numeric(15, 3), default=0)  # Quantidade cancelada
    preco_produto_pedido = db.Column(db.Numeric(15, 2), nullable=True)  # Pre√ßo unit√°rio
    
    # üí≥ CONDI√á√ïES COMERCIAIS
    cond_pgto_pedido = db.Column(db.String(100), nullable=True)  # Condi√ß√µes de pagamento
    forma_pgto_pedido = db.Column(db.String(100), nullable=True)  # Forma de pagamento
    incoterm = db.Column(db.String(20), nullable=True)  # Incoterm
    metodo_entrega_pedido = db.Column(db.String(50), nullable=True)  # M√©todo de entrega
    data_entrega_pedido = db.Column(db.Date, nullable=True)  # Data de entrega
    cliente_nec_agendamento = db.Column(db.String(10), nullable=True)  # Sim/N√£o
    observ_ped_1 = db.Column(db.Text, nullable=True)  # Observa√ß√µes
    
    # üè† ENDERE√áO DE ENTREGA COMPLETO
    cnpj_endereco_ent = db.Column(db.String(20), nullable=True)  # CNPJ entrega
    empresa_endereco_ent = db.Column(db.String(255), nullable=True)  # Nome local entrega
    cep_endereco_ent = db.Column(db.String(10), nullable=True)  # CEP
    nome_cidade = db.Column(db.String(100), nullable=True)  # Cidade extra√≠da
    cod_uf = db.Column(db.String(2), nullable=True)  # UF extra√≠da  
    bairro_endereco_ent = db.Column(db.String(100), nullable=True)  # Bairro
    rua_endereco_ent = db.Column(db.String(255), nullable=True)  # Rua
    endereco_ent = db.Column(db.String(20), nullable=True)  # N√∫mero
    telefone_endereco_ent = db.Column(db.String(20), nullable=True)  # Telefone
    
    # üìÖ DADOS OPERACIONAIS (PRESERVADOS na atualiza√ß√£o)
    expedicao = db.Column(db.Date, nullable=True)  # Data prevista expedi√ß√£o  
    data_entrega = db.Column(db.Date, nullable=True)  # Data prevista entrega
    agendamento = db.Column(db.Date, nullable=True)  # Data agendamento
    hora_agendamento = db.Column(db.Time, nullable=True)  # Hora agendamento
    protocolo = db.Column(db.String(50), nullable=True)  # Protocolo agendamento
    agendamento_confirmado = db.Column(db.Boolean, nullable=True, default=False)  # Agendamento confirmado
    roteirizacao = db.Column(db.String(100), nullable=True)  # Transportadora sugerida
    
    # üìä AN√ÅLISE DE ESTOQUE (CALCULADOS)
    menor_estoque_produto_d7 = db.Column(db.Numeric(15, 3), nullable=True)  # Previs√£o ruptura 7 dias
    saldo_estoque_pedido = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque na data expedi√ß√£o
    saldo_estoque_pedido_forcado = db.Column(db.Numeric(15, 3), nullable=True)  # Just-in-time
    
    # üöõ DADOS DE CARGA/LOTE (PRESERVADOS)
    separacao_lote_id = db.Column(db.String(50), nullable=True, index=True)  # V√≠nculo separa√ß√£o
    qtd_saldo = db.Column(db.Numeric(15, 3), nullable=True)  # Qtd no lote
    valor_saldo = db.Column(db.Numeric(15, 2), nullable=True)  # Valor no lote
    pallet = db.Column(db.Numeric(15, 3), nullable=True)  # Pallets no lote
    peso = db.Column(db.Numeric(15, 3), nullable=True)  # Peso no lote
    
    # üõ£Ô∏è DADOS DE ROTA E SUB-ROTA (ADICIONADOS)
    rota = db.Column(db.String(50), nullable=True)  # Rota principal baseada em cod_uf
    sub_rota = db.Column(db.String(50), nullable=True)  # Sub-rota baseada em cod_uf + nome_cidade
    
    # üìà TOTALIZADORES POR CLIENTE (CALCULADOS)
    valor_saldo_total = db.Column(db.Numeric(15, 2), nullable=True)  # Valor total programado CNPJ
    pallet_total = db.Column(db.Numeric(15, 3), nullable=True)  # Pallet total programado CNPJ  
    peso_total = db.Column(db.Numeric(15, 3), nullable=True)  # Peso total programado CNPJ
    valor_cliente_pedido = db.Column(db.Numeric(15, 2), nullable=True)  # Valor total carteira CNPJ
    pallet_cliente_pedido = db.Column(db.Numeric(15, 3), nullable=True)  # Pallet total carteira CNPJ
    peso_cliente_pedido = db.Column(db.Numeric(15, 3), nullable=True)  # Peso total carteira CNPJ
    
    # üìä TOTALIZADORES POR PRODUTO (CALCULADOS)
    qtd_total_produto_carteira = db.Column(db.Numeric(15, 3), nullable=True)  # Qtd total produto na carteira
    estoque = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque inicial/atual D0
    
    # üìà PROJE√á√ÉO D0-D28 (28 CAMPOS DE ESTOQUE FUTURO)
    estoque_d0 = db.Column(db.Numeric(15, 3), nullable=True)   # Estoque final D0
    estoque_d1 = db.Column(db.Numeric(15, 3), nullable=True)   # Estoque final D1
    estoque_d2 = db.Column(db.Numeric(15, 3), nullable=True)   # Estoque final D2
    estoque_d3 = db.Column(db.Numeric(15, 3), nullable=True)   # Estoque final D3
    estoque_d4 = db.Column(db.Numeric(15, 3), nullable=True)   # Estoque final D4
    estoque_d5 = db.Column(db.Numeric(15, 3), nullable=True)   # Estoque final D5
    estoque_d6 = db.Column(db.Numeric(15, 3), nullable=True)   # Estoque final D6
    estoque_d7 = db.Column(db.Numeric(15, 3), nullable=True)   # Estoque final D7
    estoque_d8 = db.Column(db.Numeric(15, 3), nullable=True)   # Estoque final D8
    estoque_d9 = db.Column(db.Numeric(15, 3), nullable=True)   # Estoque final D9
    estoque_d10 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D10
    estoque_d11 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D11
    estoque_d12 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D12
    estoque_d13 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D13
    estoque_d14 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D14
    estoque_d15 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D15
    estoque_d16 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D16
    estoque_d17 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D17
    estoque_d18 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D18
    estoque_d19 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D19
    estoque_d20 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D20
    estoque_d21 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D21
    estoque_d22 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D22
    estoque_d23 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D23
    estoque_d24 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D24
    estoque_d25 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D25
    estoque_d26 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D26
    estoque_d27 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D27
    estoque_d28 = db.Column(db.Numeric(15, 3), nullable=True)  # Estoque final D28
    
    # üõ°Ô∏è AUDITORIA
    created_at = db.Column(db.DateTime, default=agora_brasil, nullable=False)
    updated_at = db.Column(db.DateTime, default=agora_brasil, onupdate=agora_brasil, nullable=False)
    created_by = db.Column(db.String(100), nullable=True)
    updated_by = db.Column(db.String(100), nullable=True)
    ativo = db.Column(db.Boolean, default=True, index=True)
    
    # üìä √çNDICES COMPOSTOS PARA PERFORMANCE
    __table_args__ = (
        # Chave √∫nica de neg√≥cio
        db.UniqueConstraint('num_pedido', 'cod_produto', name='uq_carteira_pedido_produto'),
        # √çndices de consulta
        Index('idx_carteira_cliente_vendedor', 'cnpj_cpf', 'vendedor'),
        Index('idx_carteira_status_expedicao', 'status_pedido', 'expedicao'),
        Index('idx_carteira_produto_saldo', 'cod_produto', 'qtd_saldo_produto_pedido'),
        Index('idx_carteira_separacao_lote', 'separacao_lote_id'),
    )

    def __repr__(self):
        return f'<CarteiraPrincipal {self.num_pedido} - {self.cod_produto} - Saldo: {self.qtd_saldo_produto_pedido}>'

    def to_dict(self):
        """Converte para dicion√°rio para APIs e exporta√ß√µes"""
        return {
            'id': self.id,
            'num_pedido': self.num_pedido,
            'cod_produto': self.cod_produto,
            'nome_produto': self.nome_produto,
            'qtd_produto_pedido': float(self.qtd_produto_pedido) if self.qtd_produto_pedido else 0,
            'qtd_saldo_produto_pedido': float(self.qtd_saldo_produto_pedido) if self.qtd_saldo_produto_pedido else 0,
            'preco_produto_pedido': float(self.preco_produto_pedido) if self.preco_produto_pedido else 0,
            'cnpj_cpf': self.cnpj_cpf,
            'raz_social_red': self.raz_social_red,
            'vendedor': self.vendedor,
            'status_pedido': self.status_pedido,
            'expedicao': self.expedicao.strftime('%d/%m/%Y') if self.expedicao else None,
            'agendamento': self.agendamento.strftime('%d/%m/%Y') if self.agendamento else None,
            'protocolo': self.protocolo
        }

class CarteiraCopia(db.Model):
    """
    Modelo da carteira c√≥pia - Baseado no arquivo 2
    Controle espec√≠fico de baixas por faturamento
    """
    __tablename__ = 'carteira_copia'

    id = db.Column(db.Integer, primary_key=True)
    
    # üÜî CHAVES PRIM√ÅRIAS DE NEG√ìCIO (iguais √† principal)
    num_pedido = db.Column(db.String(50), nullable=False, index=True)
    cod_produto = db.Column(db.String(50), nullable=False, index=True)
    
    # üìã DADOS MESTRES (sincronizados com principal)
    pedido_cliente = db.Column(db.String(100), nullable=True)
    data_pedido = db.Column(db.Date, nullable=True)
    cnpj_cpf = db.Column(db.String(20), nullable=False, index=True)
    raz_social = db.Column(db.String(255), nullable=True)
    raz_social_red = db.Column(db.String(100), nullable=True)
    municipio = db.Column(db.String(100), nullable=True)
    estado = db.Column(db.String(2), nullable=True)
    vendedor = db.Column(db.String(100), nullable=True)
    equipe_vendas = db.Column(db.String(100), nullable=True)
    
    # üì¶ DADOS DO PRODUTO (sincronizados)
    nome_produto = db.Column(db.String(255), nullable=False)
    embalagem_produto = db.Column(db.String(100), nullable=True)
    materia_prima_produto = db.Column(db.String(100), nullable=True)
    categoria_produto = db.Column(db.String(100), nullable=True)
    
    # üìä QUANTIDADES E VALORES (sincronizados com principal)
    qtd_produto_pedido = db.Column(db.Numeric(15, 3), nullable=False)
    qtd_saldo_produto_pedido = db.Column(db.Numeric(15, 3), nullable=False)
    qtd_cancelada_produto_pedido = db.Column(db.Numeric(15, 3), default=0)
    preco_produto_pedido = db.Column(db.Numeric(15, 2), nullable=True)
    
    # üí≥ CONDI√á√ïES COMERCIAIS (sincronizadas)
    cond_pgto_pedido = db.Column(db.String(100), nullable=True)
    forma_pgto_pedido = db.Column(db.String(100), nullable=True)
    incoterm = db.Column(db.String(20), nullable=True)
    metodo_entrega_pedido = db.Column(db.String(50), nullable=True)
    data_entrega_pedido = db.Column(db.Date, nullable=True)
    cliente_nec_agendamento = db.Column(db.String(10), nullable=True)
    observ_ped_1 = db.Column(db.Text, nullable=True)
    status_pedido = db.Column(db.String(50), nullable=True)
    
    # üè† ENDERE√áO DE ENTREGA (sincronizado)
    cnpj_endereco_ent = db.Column(db.String(20), nullable=True)
    empresa_endereco_ent = db.Column(db.String(255), nullable=True)
    cep_endereco_ent = db.Column(db.String(10), nullable=True)
    nome_cidade = db.Column(db.String(100), nullable=True)
    cod_uf = db.Column(db.String(2), nullable=True)
    bairro_endereco_ent = db.Column(db.String(100), nullable=True)
    rua_endereco_ent = db.Column(db.String(255), nullable=True)
    endereco_ent = db.Column(db.String(20), nullable=True)
    telefone_endereco_ent = db.Column(db.String(20), nullable=True)
    
    # üí∞ CONTROLE DE FATURAMENTO (ESPEC√çFICO DA C√ìPIA)
    baixa_produto_pedido = db.Column(db.Numeric(15, 3), default=0, nullable=False)  # ‚≠ê CAMPO CHAVE
    qtd_saldo_produto_calculado = db.Column(db.Numeric(15, 3), nullable=False)  # Calculado: qtd - cancelado - baixa
    
    # üõ°Ô∏è AUDITORIA
    created_at = db.Column(db.DateTime, default=agora_brasil, nullable=False)
    updated_at = db.Column(db.DateTime, default=agora_brasil, onupdate=agora_brasil, nullable=False)
    created_by = db.Column(db.String(100), nullable=True)
    updated_by = db.Column(db.String(100), nullable=True)
    ativo = db.Column(db.Boolean, default=True, index=True)
    
    # üìä √çNDICES COMPOSTOS
    __table_args__ = (
        db.UniqueConstraint('num_pedido', 'cod_produto', name='uq_carteira_copia_pedido_produto'),
        Index('idx_copia_cliente_baixa', 'cnpj_cpf', 'baixa_produto_pedido'),
        Index('idx_copia_saldo_calculado', 'qtd_saldo_produto_calculado'),
    )

    def __repr__(self):
        return f'<CarteiraCopia {self.num_pedido} - {self.cod_produto} - Baixa: {self.baixa_produto_pedido}>'

    def recalcular_saldo(self):
        """Recalcula saldo baseado nas quantidades atuais"""
        self.qtd_saldo_produto_calculado = (
            self.qtd_produto_pedido - 
            self.qtd_cancelada_produto_pedido - 
            self.baixa_produto_pedido
        )

class ControleCruzadoSeparacao(db.Model):
    """
    Controle cruzado entre separa√ß√£o baixada em Pedidos vs Carteira C√≥pia
    Detecta diferen√ßas por ruptura de estoque ou inconsist√™ncias
    """
    __tablename__ = 'controle_cruzado_separacao'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # üÜî IDENTIFICA√á√ÉO
    separacao_lote_id = db.Column(db.String(50), nullable=False, index=True)
    num_pedido = db.Column(db.String(50), nullable=False, index=True)
    cod_produto = db.Column(db.String(50), nullable=False, index=True)
    
    # üìä QUANTIDADES
    qtd_separada_original = db.Column(db.Numeric(15,3), nullable=False)  # Quando gerou separa√ß√£o
    qtd_baixada_pedidos = db.Column(db.Numeric(15,3), nullable=True)     # Quando faturou em Pedidos
    qtd_baixada_carteira = db.Column(db.Numeric(15,3), nullable=True)    # Quando faturou na Carteira C√≥pia
    
    # üéØ STATUS E DIFEREN√áAS
    diferenca_detectada = db.Column(db.Numeric(15,3), nullable=True)  # qtd_baixada_pedidos - qtd_baixada_carteira
    status_controle = db.Column(db.String(20), default='AGUARDANDO', index=True)  # AGUARDANDO, CONFERIDO, DIFERENCA
    
    # üîß RESOLU√á√ÉO
    motivo_diferenca = db.Column(db.String(100), nullable=True)  # RUPTURA_ESTOQUE, CANCELAMENTO, etc
    resolvida = db.Column(db.Boolean, default=False, index=True)
    resolvida_por = db.Column(db.String(100), nullable=True)
    observacao_resolucao = db.Column(db.Text, nullable=True)
    
    # üõ°Ô∏è AUDITORIA
    criado_em = db.Column(db.DateTime, default=agora_brasil, nullable=False)
    conferido_em = db.Column(db.DateTime, nullable=True)
    
    # üìä √çNDICES
    __table_args__ = (
        Index('idx_controle_separacao_lote_pedido', 'separacao_lote_id', 'num_pedido'),
        Index('idx_controle_status_diferenca', 'status_controle', 'diferenca_detectada'),
    )

    def __repr__(self):
        return f'<ControleCruzado Lote:{self.separacao_lote_id} {self.num_pedido}-{self.cod_produto} Dif:{self.diferenca_detectada}>'

class InconsistenciaFaturamento(db.Model):
    """
    Gest√£o de inconsist√™ncias entre faturamento e carteira
    Para detectar e resolver NFs problem√°ticas
    """
    __tablename__ = 'inconsistencia_faturamento'
    
    id = db.Column(db.Integer, primary_key=True)
    tipo = db.Column(db.String(50), nullable=False, index=True)  # FATURAMENTO_EXCEDE_SALDO, FATURAMENTO_SEM_PEDIDO
    
    # üìã DADOS DA INCONSIST√äNCIA
    numero_nf = db.Column(db.String(20), nullable=False, index=True)
    num_pedido = db.Column(db.String(50), nullable=True)
    cod_produto = db.Column(db.String(50), nullable=False)
    
    # üìä QUANTIDADES
    qtd_faturada = db.Column(db.Numeric(15,3), nullable=False)
    saldo_disponivel = db.Column(db.Numeric(15,3), nullable=True)
    qtd_excesso = db.Column(db.Numeric(15,3), nullable=True)
    
    # üéØ STATUS E RESOLU√á√ÉO
    resolvida = db.Column(db.Boolean, default=False, index=True)
    acao_tomada = db.Column(db.String(50), nullable=True)  # CANCELAR_NF, AJUSTE_MANUAL, etc
    observacao_resolucao = db.Column(db.Text, nullable=True)
    
    # üõ°Ô∏è AUDITORIA
    detectada_em = db.Column(db.DateTime, default=agora_brasil, nullable=False)
    resolvida_em = db.Column(db.DateTime, nullable=True)
    resolvida_por = db.Column(db.String(100), nullable=True)
    
    def __repr__(self):
        return f'<Inconsistencia {self.tipo} NF:{self.numero_nf} Produto:{self.cod_produto}>'

# HistoricoFaturamento - CLASSE REMOVIDA (obsoleta)
# Funcionalidade n√£o era utilizada no sistema atual

# LogAtualizacaoCarteira - CLASSE REMOVIDA (obsoleta)
# Sistema de log n√£o implementado, funcionalidade coberta pelos logs da aplica√ß√£o

class VinculacaoCarteiraSeparacao(db.Model):
    """
    üîó VINCULA√á√ÉO MULTI-DIMENSIONAL CARTEIRA ‚Üî SEPARA√á√ÉO
    
    PROBLEMA RESOLVIDO:
    - 1 pedido pode ter m√∫ltiplas cargas
    - 1 produto pode ser dividido em v√°rias separa√ß√µes
    - Necess√°rio vincular pela tr√≠ade: protocolo + agendamento + expedi√ß√£o
    
    CHAVE DE VINCULA√á√ÉO:
    num_pedido + cod_produto + protocolo + agendamento + expedi√ß√£o
    """
    __tablename__ = 'vinculacao_carteira_separacao'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # üÜî CHAVES DE VINCULA√á√ÉO MULTI-DIMENSIONAL
    num_pedido = db.Column(db.String(50), nullable=False, index=True)
    cod_produto = db.Column(db.String(50), nullable=False, index=True)
    protocolo_agendamento = db.Column(db.String(50), nullable=False, index=True)
    data_agendamento = db.Column(db.Date, nullable=False, index=True)
    data_expedicao = db.Column(db.Date, nullable=False, index=True)
    
    # ÔøΩÔøΩ IDs DE VINCULA√á√ÉO
    carteira_item_id = db.Column(db.Integer, nullable=False, index=True)  # FK para CarteiraPrincipal
    separacao_lote_id = db.Column(db.String(50), nullable=False, index=True)  # Lote da separa√ß√£o
    
    # üìä QUANTIDADES CONTROLADAS
    qtd_carteira_original = db.Column(db.Numeric(15,3), nullable=False)  # Qtd quando criou vincula√ß√£o
    qtd_separacao_original = db.Column(db.Numeric(15,3), nullable=False)  # Qtd na separa√ß√£o
    qtd_vinculada = db.Column(db.Numeric(15,3), nullable=False)  # Qtd efetivamente vinculada
    
    # üéØ STATUS DA VINCULA√á√ÉO
    status_vinculacao = db.Column(db.String(20), default='ATIVA', index=True)  
    # ATIVA, DIVERGENTE, CANCELADA, FATURADA
    
    # üîÑ CONTROLE DE SINCRONIZA√á√ÉO
    ultima_sincronizacao = db.Column(db.DateTime, nullable=True)
    divergencia_detectada = db.Column(db.Boolean, default=False, index=True)
    tipo_divergencia = db.Column(db.String(50), nullable=True)  
    # QTD_ALTERADA, ITEM_CANCELADO, ITEM_FATURADO, PROTOCOLO_ALTERADO
    
    # üõ°Ô∏è AUDITORIA
    criada_em = db.Column(db.DateTime, default=agora_brasil, nullable=False)
    criada_por = db.Column(db.String(100), nullable=False)
    atualizada_em = db.Column(db.DateTime, default=agora_brasil, onupdate=agora_brasil)
    
    # üìä √çNDICES COMPOSTOS CR√çTICOS
    __table_args__ = (
        # Chave √∫nica de vincula√ß√£o multi-dimensional
        db.UniqueConstraint(
            'num_pedido', 'cod_produto', 'protocolo_agendamento', 
            'data_agendamento', 'data_expedicao',
            name='uq_vinculacao_multi_dimensional'
        ),
        # √çndices de performance
        Index('idx_vinculacao_status_divergencia', 'status_vinculacao', 'divergencia_detectada'),
        Index('idx_vinculacao_carteira_separacao', 'carteira_item_id', 'separacao_lote_id'),
        Index('idx_vinculacao_protocolo_data', 'protocolo_agendamento', 'data_agendamento'),
    )

    def __repr__(self):
        return f'<VinculacaoCarteiraSeparacao {self.num_pedido}-{self.cod_produto} Protocolo:{self.protocolo_agendamento}>' 

class EventoCarteira(db.Model):
    """
    üéØ RASTREAMENTO DE EVENTOS DA CARTEIRA
    
    PROBLEMA RESOLVIDO:
    - Saber se item sumiu por FATURAMENTO ou CANCELAMENTO
    - Auditoria completa de todas as mudan√ßas
    - Reconcilia√ß√£o autom√°tica entre sistemas
    """
    __tablename__ = 'evento_carteira'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # üÜî IDENTIFICA√á√ÉO
    num_pedido = db.Column(db.String(50), nullable=False, index=True)
    cod_produto = db.Column(db.String(50), nullable=False, index=True)
    carteira_item_id = db.Column(db.Integer, nullable=False, index=True)
    
    # üéØ TIPO DE EVENTO
    tipo_evento = db.Column(db.String(30), nullable=False, index=True)
    # FATURAMENTO, CANCELAMENTO, ALTERACAO_QTD, ALTERACAO_PROTOCOLO, 
    # ALTERACAO_AGENDAMENTO, ALTERACAO_EXPEDICAO
    
    # üìä DADOS DO EVENTO
    qtd_anterior = db.Column(db.Numeric(15,3), nullable=True)
    qtd_nova = db.Column(db.Numeric(15,3), nullable=True)
    qtd_impactada = db.Column(db.Numeric(15,3), nullable=False)  # Diferen√ßa
    
    # üìã DETALHES ESPEC√çFICOS
    numero_nf = db.Column(db.String(20), nullable=True)  # Para FATURAMENTO
    motivo_cancelamento = db.Column(db.String(100), nullable=True)  # Para CANCELAMENTO
    campo_alterado = db.Column(db.String(50), nullable=True)  # Para ALTERACAO_*
    valor_anterior = db.Column(db.String(255), nullable=True)  # Valor anterior do campo
    valor_novo = db.Column(db.String(255), nullable=True)  # Novo valor do campo
    
    # üîÑ IMPACTO NA SEPARA√á√ÉO
    afeta_separacao = db.Column(db.Boolean, default=False, index=True)
    separacao_notificada = db.Column(db.Boolean, default=False, index=True)
    cotacao_afetada = db.Column(db.Boolean, default=False, index=True)
    responsavel_cotacao = db.Column(db.String(100), nullable=True)
    
    # üéØ STATUS DO EVENTO
    status_processamento = db.Column(db.String(20), default='PENDENTE', index=True)
    # PENDENTE, PROCESSADO, REJEITADO, AGUARDA_APROVACAO
    
    # üõ°Ô∏è AUDITORIA
    criado_em = db.Column(db.DateTime, default=agora_brasil, nullable=False)
    criado_por = db.Column(db.String(100), nullable=False)
    processado_em = db.Column(db.DateTime, nullable=True)
    processado_por = db.Column(db.String(100), nullable=True)
    
    # üìä √çNDICES
    __table_args__ = (
        Index('idx_evento_tipo_status', 'tipo_evento', 'status_processamento'),
        Index('idx_evento_cotacao_afetada', 'cotacao_afetada', 'responsavel_cotacao'),
        Index('idx_evento_separacao_notificada', 'afeta_separacao', 'separacao_notificada'),
        Index('idx_evento_pedido_produto', 'num_pedido', 'cod_produto'),
    )

    def __repr__(self):
        return f'<EventoCarteira {self.tipo_evento} {self.num_pedido}-{self.cod_produto} Qtd:{self.qtd_impactada}>' 

class AprovacaoMudancaCarteira(db.Model):
    """
    ‚úÖ SISTEMA DE APROVA√á√ÉO PARA MUDAN√áAS EM PEDIDOS COTADOS
    
    PROBLEMA RESOLVIDO:
    - Mudan√ßas em pedidos cotados precisam de aprova√ß√£o
    - √Årea espec√≠fica para quem cotou visualizar mudan√ßas
    - Workflow de aprova√ß√£o sem passar batido
    """
    __tablename__ = 'aprovacao_mudanca_carteira'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # üÜî IDENTIFICA√á√ÉO
    evento_carteira_id = db.Column(db.Integer, nullable=False, index=True)  # FK para EventoCarteira
    num_pedido = db.Column(db.String(50), nullable=False, index=True)
    cod_produto = db.Column(db.String(50), nullable=False, index=True)
    
    # üéØ DADOS DA COTA√á√ÉO AFETADA
    cotacao_id = db.Column(db.Integer, nullable=True, index=True)  # FK para CotacaoItem (se existir)
    responsavel_cotacao = db.Column(db.String(100), nullable=False, index=True)
    valor_frete_cotado = db.Column(db.Numeric(15,2), nullable=True)
    transportadora_cotada = db.Column(db.String(100), nullable=True)
    
    # üìã DETALHES DA MUDAN√áA
    tipo_mudanca = db.Column(db.String(30), nullable=False)
    # ALTERACAO_QTD, CANCELAMENTO_ITEM, ALTERACAO_PROTOCOLO, ALTERACAO_DATA
    descricao_mudanca = db.Column(db.Text, nullable=False)
    impacto_estimado = db.Column(db.String(20), nullable=False)  # BAIXO, MEDIO, ALTO, CRITICO
    
    # üéØ STATUS DA APROVA√á√ÉO
    status_aprovacao = db.Column(db.String(20), default='AGUARDA_VISUALIZACAO', index=True)
    # AGUARDA_VISUALIZACAO, VISUALIZADA, APROVADA, REJEITADA, EXPIRADA
    
    # ‚è∞ CONTROLE DE TEMPO
    prazo_resposta = db.Column(db.DateTime, nullable=False)  # 24h para visualizar, 48h para aprovar
    notificacoes_enviadas = db.Column(db.Integer, default=0)
    ultima_notificacao = db.Column(db.DateTime, nullable=True)
    
    # ‚úÖ RESPOSTA DO RESPONS√ÅVEL
    visualizada_em = db.Column(db.DateTime, nullable=True)
    respondida_em = db.Column(db.DateTime, nullable=True)
    observacao_resposta = db.Column(db.Text, nullable=True)
    acao_tomada = db.Column(db.String(50), nullable=True)
    # ACEITAR_MUDANCA, REJEITAR_MUDANCA, REQUOTAR_FRETE, CANCELAR_COTACAO
    
    # üîÑ A√á√ïES AUTOM√ÅTICAS
    acao_automatica_aplicada = db.Column(db.Boolean, default=False)
    motivo_acao_automatica = db.Column(db.String(100), nullable=True)
    
    # üõ°Ô∏è AUDITORIA
    criada_em = db.Column(db.DateTime, default=agora_brasil, nullable=False)
    criada_por = db.Column(db.String(100), nullable=False)
    
    # üìä √çNDICES
    __table_args__ = (
        Index('idx_aprovacao_responsavel_status', 'responsavel_cotacao', 'status_aprovacao'),
        Index('idx_aprovacao_prazo_status', 'prazo_resposta', 'status_aprovacao'),
        Index('idx_aprovacao_impacto_status', 'impacto_estimado', 'status_aprovacao'),
        Index('idx_aprovacao_pedido_produto', 'num_pedido', 'cod_produto'),
    )

    def __repr__(self):
        return f'<AprovacaoMudanca {self.num_pedido}-{self.cod_produto} Por:{self.responsavel_cotacao} Status:{self.status_aprovacao}>'
    
    def esta_vencida(self):
        """Verifica se a aprova√ß√£o est√° vencida"""
        return agora_brasil() > self.prazo_resposta and self.status_aprovacao in ['AGUARDA_VISUALIZACAO', 'VISUALIZADA']
    
    def precisa_notificacao(self):
        """Verifica se precisa enviar notifica√ß√£o"""
        if self.status_aprovacao not in ['AGUARDA_VISUALIZACAO', 'VISUALIZADA']:
            return False
        
        # Primeira notifica√ß√£o imediata
        if self.notificacoes_enviadas == 0:
            return True
            
        # Notifica√ß√µes subsequentes a cada 4 horas
        if self.ultima_notificacao:
            tempo_desde_ultima = agora_brasil() - self.ultima_notificacao
            return tempo_desde_ultima.total_seconds() > 14400  # 4 horas
            
        return False 

class TipoCarga(db.Model):
    """
    üéØ CONTROLE DE TIPO DE CARGA - SOLU√á√ÉO PARA CONFLITO DE REGRAS
    
    PROBLEMA RESOLVIDO:
    - Separa√ß√£o parcial vs preservar dados operacionais
    - Altera√ß√µes podem tornar carga invi√°vel (peso limite)
    - Necessidade de controle inteligente de capacidade
    """
    __tablename__ = 'tipo_carga'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # üÜî IDENTIFICA√á√ÉO DA CARGA
    separacao_lote_id = db.Column(db.String(50), nullable=False, unique=True, index=True)
    
    # üéØ TIPO DE ENVIO (SOLU√á√ÉO PRINCIPAL)
    tipo_envio = db.Column(db.String(20), nullable=False, default='TOTAL', index=True)
    # TOTAL: Carga completa - aceita altera√ß√µes at√© o limite
    # PARCIAL: Carga parcial planejada - altera√ß√µes v√£o para nova carga  
    # COMPLEMENTAR: Carga para completar PARCIAL anterior
    # STANDBY: Aguardando defini√ß√£o comercial
    
    # üìä CAPACIDADES E LIMITES
    capacidade_maxima_peso = db.Column(db.Numeric(15,3), nullable=True)     # Peso m√°ximo suportado
    capacidade_maxima_pallets = db.Column(db.Numeric(15,3), nullable=True)  # Pallets m√°ximos
    capacidade_maxima_valor = db.Column(db.Numeric(15,2), nullable=True)    # Valor m√°ximo (seguro)
    
    # üìà UTILIZA√á√ÉO ATUAL  
    peso_atual = db.Column(db.Numeric(15,3), default=0, nullable=False)
    pallets_atual = db.Column(db.Numeric(15,3), default=0, nullable=False)
    valor_atual = db.Column(db.Numeric(15,2), default=0, nullable=False)
    
    # üîÑ COMPORTAMENTO PARA ALTERA√á√ïES
    aceita_incremento = db.Column(db.Boolean, default=True, nullable=False)
    # True: Altera√ß√µes s√£o adicionadas √† carga existente
    # False: Altera√ß√µes v√£o para nova carga (em branco)
    
    # üìã JUSTIFICATIVA E CONTROLE
    motivo_tipo = db.Column(db.String(200), nullable=True)
    # "Carga completa planejada", "Separa√ß√£o parcial por peso", etc.
    
    criado_por = db.Column(db.String(100), nullable=False)
    criado_em = db.Column(db.DateTime, default=agora_brasil, nullable=False)
    
    # üîó RELACIONAMENTO COM COMPLEMENTARES
    carga_principal_id = db.Column(db.Integer, db.ForeignKey('tipo_carga.id'), nullable=True)
    # Para cargas COMPLEMENTAR, aponta para a PARCIAL original
    
    def __repr__(self):
        return f'<FlexibilidadeCarga {self.separacao_lote_id} - {self.tipo_envio}>'
    
    @property
    def pode_aceitar_alteracao(self):
        """Verifica se a carga pode aceitar mais itens"""
        if not self.aceita_incremento:
            return False
            
        # Verifica limites de capacidade
        if self.capacidade_maxima_peso and self.peso_atual >= self.capacidade_maxima_peso:
            return False
            
        return True
    
    @property
    def percentual_utilizacao_peso(self):
        """Percentual de utiliza√ß√£o do peso"""
        if not self.capacidade_maxima_peso:
            return 0
        return (float(self.peso_atual) / float(self.capacidade_maxima_peso)) * 100


class FaturamentoParcialJustificativa(db.Model):
    """
    üìã JUSTIFICATIVAS PARA FATURAMENTO PARCIAL
    
    PROBLEMA RESOLVIDO:
    - Separou 100, faturou 60 ‚Üí Por que 40 n√£o foram?
    - Tratamento inteligente do saldo restante
    - Decis√£o comercial sobre destino do saldo
    """
    __tablename__ = 'faturamento_parcial_justificativa'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # üÜî IDENTIFICA√á√ÉO
    separacao_lote_id = db.Column(db.String(50), nullable=False, index=True)
    num_pedido = db.Column(db.String(50), nullable=False, index=True)
    cod_produto = db.Column(db.String(50), nullable=False, index=True)
    numero_nf = db.Column(db.String(20), nullable=False, index=True)
    
    # üìä QUANTIDADES
    qtd_separada = db.Column(db.Numeric(15,3), nullable=False)     # Quantidade na separa√ß√£o
    qtd_faturada = db.Column(db.Numeric(15,3), nullable=False)     # Quantidade faturada
    qtd_saldo = db.Column(db.Numeric(15,3), nullable=False)        # Saldo n√£o faturado
    
    # üîç MOTIVO DO FATURAMENTO PARCIAL
    motivo_nao_faturamento = db.Column(db.String(20), nullable=False, index=True)
    # RUPTURA_ESTOQUE: Produto em falta
    # AVARIA_PRODUTO: Produto com defeito
    # ERRO_SEPARACAO: Separaram quantidade errada
    # ALTERACAO_PEDIDO: Cliente alterou pedido
    # CANCELAMENTO_PARCIAL: Cliente cancelou parte
    # RESTRICAO_TRANSPORTE: N√£o coube no ve√≠culo
    # OUTROS: Outros motivos
    
    # üìù DETALHAMENTO
    descricao_detalhada = db.Column(db.Text, nullable=True)
    evidencias_anexas = db.Column(db.String(500), nullable=True)  # URLs de arquivos
    
    # üéØ CLASSIFICA√á√ÉO DO SALDO
    classificacao_saldo = db.Column(db.String(20), nullable=False, index=True)
    # SALDO: Pode ser reaproveitado ou descartado
    # NECESSITA_COMPLEMENTO: Aguarda reposi√ß√£o/novo pedido
    # RETORNA_CARTEIRA: Volta √† carteira com dados limpos
    # EXCLUIR_DEFINITIVO: Remove da carteira definitivamente
    
    # üìã A√á√ÉO COMERCIAL TOMADA
    acao_comercial = db.Column(db.String(20), nullable=True, index=True)
    # AGUARDA_DECISAO: Pendente de an√°lise comercial
    # RETORNOU_CARTEIRA: Voltou √† carteira sem dados operacionais
    # NOVA_SEPARACAO: Criou nova separa√ß√£o
    # AGUARDA_REPOSICAO: Em standby para reposi√ß√£o
    # DESCARTADO: Removido definitivamente
    
    data_acao = db.Column(db.DateTime, nullable=True)
    executado_por = db.Column(db.String(100), nullable=True)
    observacoes_acao = db.Column(db.Text, nullable=True)
    
    # üõ°Ô∏è AUDITORIA
    criado_em = db.Column(db.DateTime, default=agora_brasil, nullable=False)
    criado_por = db.Column(db.String(100), nullable=False)
    
    # üìä √çNDICES
    __table_args__ = (
        Index('idx_justificativa_separacao_pedido', 'separacao_lote_id', 'num_pedido'),
        Index('idx_justificativa_motivo_classificacao', 'motivo_nao_faturamento', 'classificacao_saldo'),
        Index('idx_justificativa_acao', 'acao_comercial', 'data_acao'),
    )

    def __repr__(self):
        return f'<FaturamentoParcial {self.separacao_lote_id} {self.num_pedido} - {self.motivo_nao_faturamento}>'


class ControleAlteracaoCarga(db.Model):
    """
    ‚öñÔ∏è CONTROLE INTELIGENTE DE ALTERA√á√ïES NA CARGA
    
    PROBLEMA RESOLVIDO:
    - Pedido tinha 100, separou 60, carteira importada com 120
    - Decidir se adiciona +20 na carga ou cria nova carga
    - Validar se carga suporta altera√ß√£o (peso, dimens√µes)
    """
    __tablename__ = 'controle_alteracao_carga'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # üÜî IDENTIFICA√á√ÉO
    carteira_item_id = db.Column(db.Integer, nullable=False, index=True)
    separacao_lote_id = db.Column(db.String(50), nullable=False, index=True)
    num_pedido = db.Column(db.String(50), nullable=False, index=True)
    cod_produto = db.Column(db.String(50), nullable=False, index=True)
    
    # üìä ALTERA√á√ÉO DETECTADA
    qtd_anterior = db.Column(db.Numeric(15,3), nullable=False)      # Quantidade antes da altera√ß√£o
    qtd_nova = db.Column(db.Numeric(15,3), nullable=False)          # Quantidade ap√≥s altera√ß√£o
    qtd_diferenca = db.Column(db.Numeric(15,3), nullable=False)     # Diferen√ßa (+/-)
    
    peso_anterior = db.Column(db.Numeric(15,3), nullable=True)
    peso_novo = db.Column(db.Numeric(15,3), nullable=True)
    peso_diferenca = db.Column(db.Numeric(15,3), nullable=True)
    
    # üéØ DECIS√ÉO TOMADA
    decisao_sistema = db.Column(db.String(20), nullable=False, index=True)
    # ADICIONAR_CARGA_ATUAL: Adicionou √† carga existente
    # CRIAR_NOVA_CARGA: Criou nova carga para a diferen√ßa
    # REJEITAR_ALTERACAO: Manteve dados originais
    # AGUARDA_APROVACAO: Pendente de decis√£o manual
    
    # üîç MOTIVO DA DECIS√ÉO
    motivo_decisao = db.Column(db.String(200), nullable=True)
    # "Carga suporta +20kg", "Peso excederia limite", etc.
    
    # üìã VALIDA√á√ïES DE CAPACIDADE
    capacidade_peso_ok = db.Column(db.Boolean, nullable=True)
    capacidade_pallets_ok = db.Column(db.Boolean, nullable=True)
    capacidade_valor_ok = db.Column(db.Boolean, nullable=True)
    
    # üîÑ A√á√ÉO EXECUTADA
    acao_executada = db.Column(db.String(20), nullable=True, index=True)
    # EXECUTADA: A√ß√£o foi aplicada
    # PENDENTE: Aguarda execu√ß√£o
    # CANCELADA: Decis√£o cancelada
    
    nova_carga_criada_id = db.Column(db.String(50), nullable=True)  # Se criou nova carga
    
    # üõ°Ô∏è AUDITORIA
    detectado_em = db.Column(db.DateTime, default=agora_brasil, nullable=False)
    processado_em = db.Column(db.DateTime, nullable=True)
    processado_por = db.Column(db.String(100), nullable=True)
    
    def __repr__(self):
        return f'<ControleAlteracao {self.num_pedido} {self.decisao_sistema}: {self.qtd_diferenca}>'


class SaldoStandby(db.Model):
    """
    ‚è∏Ô∏è SALDOS EM STANDBY - AGUARDANDO DECIS√ÉO COMERCIAL
    
    PROBLEMA RESOLVIDO:
    - "NECESSITA COMPLEMENTO" ‚Üí Aguarda novo pedido do CNPJ
    - Controle temporal de saldos parados
    - Decis√£o comercial sobre destino final
    """
    __tablename__ = 'saldo_standby'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # üÜî IDENTIFICA√á√ÉO
    origem_separacao_lote_id = db.Column(db.String(50), nullable=False, index=True)
    num_pedido = db.Column(db.String(50), nullable=False, index=True)
    cod_produto = db.Column(db.String(50), nullable=False, index=True)
    cnpj_cliente = db.Column(db.String(20), nullable=False, index=True)
    nome_cliente = db.Column(db.String(255), nullable=False)
    
    # üìä DADOS DO SALDO
    qtd_saldo = db.Column(db.Numeric(15,3), nullable=False)
    valor_saldo = db.Column(db.Numeric(15,2), nullable=False)
    peso_saldo = db.Column(db.Numeric(15,3), nullable=True)
    pallet_saldo = db.Column(db.Numeric(15,3), nullable=True)
    
    # üéØ TIPO DE STANDBY
    tipo_standby = db.Column(db.String(20), nullable=False, index=True)
    # AGUARDA_COMPLEMENTO: Aguarda novo pedido mesmo CNPJ
    # AGUARDA_DECISAO: Aguarda decis√£o comercial
    # AGUARDA_REPOSICAO: Aguarda reposi√ß√£o de estoque
    
    # üìÖ CONTROLE TEMPORAL
    data_limite_standby = db.Column(db.Date, nullable=True)  # Prazo m√°ximo em standby
    dias_em_standby = db.Column(db.Integer, default=0)       # Contador autom√°tico
    
    # üîî ALERTAS E NOTIFICA√á√ïES
    alertas_enviados = db.Column(db.Integer, default=0)
    proximo_alerta = db.Column(db.Date, nullable=True)
    
    # üéØ RESOLU√á√ÉO
    status_standby = db.Column(db.String(20), default='ATIVO', index=True)
    # ATIVO: Em standby aguardando
    # RESOLVIDO: Problema resolvido
    # DESCARTADO: Removido definitivamente
    # TRANSFERIDO: Transferido para nova carga
    
    resolucao_final = db.Column(db.String(20), nullable=True)
    data_resolucao = db.Column(db.DateTime, nullable=True)
    resolvido_por = db.Column(db.String(100), nullable=True)
    observacoes_resolucao = db.Column(db.Text, nullable=True)
    
    # üõ°Ô∏è AUDITORIA
    criado_em = db.Column(db.DateTime, default=agora_brasil, nullable=False)
    criado_por = db.Column(db.String(100), nullable=False)
    
    def __repr__(self):
        return f'<SaldoStandby {self.num_pedido} {self.cod_produto} - {self.qtd_saldo} - {self.tipo_standby}>'
    
    @property
    def dias_em_standby_calculado(self):
        """Calcula dias em standby automaticamente"""
        if self.status_standby != 'ATIVO':
            return self.dias_em_standby
            
        delta = datetime.now().date() - self.criado_em.date()
        return delta.days
    
    @property
    def precisa_alerta(self):
        """Verifica se precisa enviar alerta"""
        if self.status_standby != 'ATIVO':
            return False
            
        hoje = datetime.now().date()
        return not self.proximo_alerta or hoje >= self.proximo_alerta 

class ControleDescasamentoNF(db.Model):
    """
    üö® CONTROLE CR√çTICO DE DESCASAMENTO - SOLU√á√ÉO PARA PROBLEMA IDENTIFICADO
    
    PROBLEMA RESOLVIDO:
    - NF preenchida em Embarques ‚â† NF importada na carteira
    - Impacto direto em separa√ß√µes e justificativas parciais
    - Sincroniza√ß√£o autom√°tica entre todos os sistemas
    """
    __tablename__ = 'controle_descasamento_nf'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # üÜî IDENTIFICA√á√ÉO DA NF
    numero_nf = db.Column(db.String(20), nullable=False, index=True)
    num_pedido = db.Column(db.String(50), nullable=False, index=True)
    cod_produto = db.Column(db.String(50), nullable=False, index=True)
    
    # üìä QUANTIDADES DOS 3 SISTEMAS
    qtd_embarques = db.Column(db.Numeric(15,3), nullable=True)        # Preenchido em Embarques
    qtd_importacao = db.Column(db.Numeric(15,3), nullable=True)       # Importa√ß√£o carteira
    qtd_separacao = db.Column(db.Numeric(15,3), nullable=True)        # Separa√ß√£o original
    
    # ‚ö†Ô∏è DETEC√á√ÉO AUTOM√ÅTICA DE PROBLEMAS
    descasamento_detectado = db.Column(db.Boolean, default=False, index=True)
    tipo_descasamento = db.Column(db.String(50), nullable=True)
    # EMBARQUE_MAIOR_IMPORTACAO: Embarque faturou mais que carteira importou
    # IMPORTACAO_MAIOR_EMBARQUE: Carteira importou mais que embarque faturou
    # EXCEDE_SEPARACAO: Qualquer faturamento > separa√ß√£o original
    # DADOS_FALTANTES: Um dos sistemas sem dados
    
    diferenca_critica = db.Column(db.Numeric(15,3), nullable=True)    # Magnitude da diferen√ßa
    
    # üéØ IMPACTOS IDENTIFICADOS
    impacta_separacao = db.Column(db.Boolean, default=False)
    separacao_lote_id = db.Column(db.String(50), nullable=True, index=True)
    justificativa_invalida = db.Column(db.Boolean, default=False)
    justificativa_id = db.Column(db.Integer, nullable=True)  # FK para FaturamentoParcialJustificativa
    
    # üîß RESOLU√á√ÉO AUTOM√ÅTICA
    acao_automatica = db.Column(db.String(50), nullable=True)
    # SINCRONIZAR_EMBARQUE: Usar dados da importa√ß√£o no embarque
    # SINCRONIZAR_CARTEIRA: Usar dados do embarque na carteira
    # CORRIGIR_SEPARACAO: Ajustar separa√ß√£o conforme realidade
    # RECRIAR_JUSTIFICATIVA: Refazer justificativa com dados corretos
    # AGUARDA_MANUAL: Precisa interven√ß√£o humana
    
    acao_executada = db.Column(db.Boolean, default=False)
    executada_em = db.Column(db.DateTime, nullable=True)
    
    # üìã DADOS PARA RECONCILIA√á√ÉO
    fonte_correta = db.Column(db.String(20), nullable=True)  # EMBARQUES, IMPORTACAO, MEDIA
    qtd_reconciliada = db.Column(db.Numeric(15,3), nullable=True)    # Quantidade final acordada
    motivo_escolha = db.Column(db.String(200), nullable=True)
    
    # üõ°Ô∏è AUDITORIA
    detectado_em = db.Column(db.DateTime, default=agora_brasil, nullable=False)
    resolvido_em = db.Column(db.DateTime, nullable=True)
    resolvido_por = db.Column(db.String(100), nullable=True)
    observacoes = db.Column(db.Text, nullable=True)
    
    # üìä √çNDICES PARA PERFORMANCE
    __table_args__ = (
        Index('idx_descasamento_nf_pedido', 'numero_nf', 'num_pedido'),
        Index('idx_descasamento_detectado_impacto', 'descasamento_detectado', 'impacta_separacao'),
        Index('idx_descasamento_acao', 'acao_automatica', 'acao_executada'),
        Index('idx_descasamento_separacao', 'separacao_lote_id', 'justificativa_invalida'),
    )

    def __repr__(self):
        return f'<ControleDescasamento NF:{self.numero_nf} {self.tipo_descasamento} - Diff:{self.diferenca_critica}>'
    
    @property
    def percentual_diferenca(self):
        """Calcula percentual da diferen√ßa em rela√ß√£o √† separa√ß√£o"""
        if not self.qtd_separacao or self.qtd_separacao == 0:
            return 0
        return abs(float(self.diferenca_critica) / float(self.qtd_separacao)) * 100
    
    @property 
    def criticidade(self):
        """Classifica criticidade do descasamento"""
        perc = self.percentual_diferenca
        if perc == 0:
            return 'NENHUMA'
        elif perc <= 5:
            return 'BAIXA'
        elif perc <= 15:
            return 'MEDIA'
        elif perc <= 30:
            return 'ALTA'
        else:
            return 'CRITICA'
            
    def detectar_descasamento(self):
        """Algoritmo inteligente para detectar descasamento"""
        if not self.qtd_embarques or not self.qtd_importacao:
            self.tipo_descasamento = 'DADOS_FALTANTES'
            self.descasamento_detectado = True
            return
            
        # Compara√ß√£o principal
        diff = abs(float(self.qtd_embarques) - float(self.qtd_importacao))
        
        if diff == 0:
            self.descasamento_detectado = False
            return
        
        self.diferenca_critica = diff
        self.descasamento_detectado = True
        
        # Classifica√ß√£o do tipo
        if self.qtd_embarques > self.qtd_importacao:
            self.tipo_descasamento = 'EMBARQUE_MAIOR_IMPORTACAO'
        else:
            self.tipo_descasamento = 'IMPORTACAO_MAIOR_EMBARQUE'
            
        # Verifica√ß√£o cr√≠tica vs separa√ß√£o
        if self.qtd_separacao:
            if max(self.qtd_embarques, self.qtd_importacao) > self.qtd_separacao:
                self.tipo_descasamento = 'EXCEDE_SEPARACAO'
                self.impacta_separacao = True
                
    def sugerir_acao_automatica(self):
        """Sugere a√ß√£o autom√°tica baseada na an√°lise"""
        if not self.descasamento_detectado:
            return
            
        if self.tipo_descasamento == 'DADOS_FALTANTES':
            self.acao_automatica = 'AGUARDA_MANUAL'
        elif self.tipo_descasamento == 'EXCEDE_SEPARACAO':
            self.acao_automatica = 'CORRIGIR_SEPARACAO'
        elif self.percentual_diferenca <= 5:  # Diferen√ßa pequena
            # Usar fonte com maior credibilidade (importa√ß√£o √© mais recente)
            self.acao_automatica = 'SINCRONIZAR_EMBARQUE'
            self.fonte_correta = 'IMPORTACAO'
        else:
            self.acao_automatica = 'AGUARDA_MANUAL' 

class SnapshotCarteira(db.Model):
    """
    üì∏ SNAPSHOT NA IMPORTA√á√ÉO DA CARTEIRA - SOLU√á√ÉO CORRIGIDA
    
    MOMENTO CORRETO:
    - Snapshot criado na IMPORTA√á√ÉO da carteira
    - Separa√ß√£o pode ser alterada ap√≥s snapshot
    - Faturamento sempre validado contra snapshot original
    """
    __tablename__ = 'snapshot_carteira'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # üÜî IDENTIFICA√á√ÉO
    data_importacao = db.Column(db.DateTime, default=agora_brasil, nullable=False, index=True)
    versao_carteira = db.Column(db.String(50), nullable=False, index=True)  # Ex: "2025-06-30-18h30"
    
    # üìã DADOS DO PEDIDO (PRESERVADOS NO MOMENTO DA IMPORTA√á√ÉO)
    num_pedido = db.Column(db.String(50), nullable=False, index=True)
    cod_produto = db.Column(db.String(50), nullable=False, index=True)
    cnpj_cliente = db.Column(db.String(20), nullable=False, index=True)
    nome_cliente = db.Column(db.String(255), nullable=False)
    qtd_produto_pedido = db.Column(db.Float, nullable=False)
    preco_produto = db.Column(db.Float, nullable=False)
    valor_produto_pedido = db.Column(db.Float, nullable=False)
    
    # üîó CHAVE √öNICA
    __table_args__ = (
        db.UniqueConstraint('num_pedido', 'cod_produto', 'versao_carteira'),
    )


class TipoEnvio(db.Model):
    """
    üéØ TIPO DE ENVIO SIMPLIFICADO - PARCIAL/TOTAL
    """
    __tablename__ = 'tipo_envio'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # üÜî IDENTIFICA√á√ÉO DA CARGA
    separacao_lote_id = db.Column(db.String(50), nullable=False, unique=True, index=True)
    
    # üéØ TIPO DE ENVIO
    tipo_envio = db.Column(db.String(20), nullable=False, default='TOTAL', index=True)
    # TOTAL: Carga completa - aceita altera√ß√µes at√© o limite
    # PARCIAL: Carga parcial planejada - altera√ß√µes v√£o para nova carga
    
    # üìä CONTROLE DE CAPACIDADE
    capacidade_peso_kg = db.Column(db.Float, nullable=True, default=0)
    capacidade_volume_m3 = db.Column(db.Float, nullable=True, default=0)
    peso_atual_kg = db.Column(db.Float, nullable=False, default=0)
    volume_atual_m3 = db.Column(db.Float, nullable=False, default=0)
    
    # üìÖ AUDITORIA
    criado_em = db.Column(db.DateTime, default=agora_brasil, nullable=False)
    criado_por = db.Column(db.String(100), nullable=False)
    
    @property
    def capacidade_disponivel_peso(self):
        """Peso dispon√≠vel em kg"""
        if self.capacidade_peso_kg and self.capacidade_peso_kg > 0:
            return max(0, self.capacidade_peso_kg - self.peso_atual_kg)
        return float('inf')  # Sem limite
    
    @property  
    def capacidade_disponivel_volume(self):
        """Volume dispon√≠vel em m¬≥"""
        if self.capacidade_volume_m3 and self.capacidade_volume_m3 > 0:
            return max(0, self.capacidade_volume_m3 - self.volume_atual_m3)
        return float('inf')  # Sem limite


class PreSeparacaoItem(db.Model):
    """
    Modelo para sistema de pr√©-separa√ß√£o que SOBREVIVE √† reimporta√ß√£o do Odoo
    
    FUNCIONALIDADE CR√çTICA: Quando Odoo reimporta e SUBSTITUI a carteira_principal,
    este modelo preserva as decis√µes dos usu√°rios e permite "recompor" as divis√µes.
    
    FLUXO DE RECOMPOSI√á√ÉO:
    1. Usu√°rio faz pr√©-separa√ß√£o (divis√£o parcial)
    2. Sistema salva dados com chave de neg√≥cio est√°vel  
    3. Odoo reimporta ‚Üí carteira_principal √© substitu√≠da
    4. Sistema detecta pr√©-separa√ß√µes n√£o recompostas
    5. Aplica novamente as divis√µes na nova carteira
    6. Preserva dados edit√°veis (datas, protocolos, etc.)
    """
    
    __tablename__ = 'pre_separacao_item'
    
    # Campos principais
    id = db.Column(db.Integer, primary_key=True)
    num_pedido = db.Column(db.String(50), nullable=False, index=True)
    cod_produto = db.Column(db.String(50), nullable=False, index=True) 
    cnpj_cliente = db.Column(db.String(20), index=True)
    
    #  DADOS ORIGINAIS (momento da pr√©-separa√ß√£o)
    nome_produto = db.Column(db.String(255), nullable=True)
    qtd_original_carteira = db.Column(db.Numeric(15, 3), nullable=False)  # Qtd total no momento
    qtd_selecionada_usuario = db.Column(db.Numeric(15, 3), nullable=False)  # Qtd escolhida
    qtd_restante_calculada = db.Column(db.Numeric(15, 3), nullable=False)  # Saldo restante
    
    # Dados originais preservados (sobreviv√™ncia √† reimporta√ß√£o)
    valor_original_item = db.Column(db.Numeric(15,2))
    peso_original_item = db.Column(db.Numeric(15,3))
    hash_item_original = db.Column(db.String(128))
    
    # Trabalho do usu√°rio preservado
    data_expedicao_editada = db.Column(db.Date)
    data_agendamento_editada = db.Column(db.Date)
    protocolo_editado = db.Column(db.String(50))
    observacoes_usuario = db.Column(db.Text)
    
    # Controle de recomposi√ß√£o (sobreviv√™ncia ao Odoo)
    recomposto = db.Column(db.Boolean, default=False, index=True)
    data_recomposicao = db.Column(db.DateTime)
    recomposto_por = db.Column(db.String(100))
    versao_carteira_original = db.Column(db.String(50))
    versao_carteira_recomposta = db.Column(db.String(50))
    
    # Status e tipo
    status = db.Column(db.String(20), default='CRIADO', index=True)  # CRIADO, RECOMPOSTO, ENVIADO_SEPARACAO
    tipo_envio = db.Column(db.String(10), default='total')  # total, parcial
    
    # Auditoria
    data_criacao = db.Column(db.DateTime, default=datetime.utcnow)
    criado_por = db.Column(db.String(100))
    
    # Removida constraint √∫nica para permitir m√∫ltiplas pr√©-separa√ß√µes do mesmo produto
    # M√∫ltiplas pr√©-separa√ß√µes fazem parte do processo normal de opera√ß√£o
    
    def __repr__(self):
        return f'<PreSeparacaoItem {self.num_pedido}-{self.cod_produto}: {self.qtd_selecionada_usuario}/{self.qtd_original_carteira}>'
    
    # ===== PROPERTIES CALCULADAS =====
    
    @property
    def valor_selecionado(self):
        """Valor da quantidade selecionada"""
        if self.valor_original_item and self.qtd_original_carteira:
            return (float(self.qtd_selecionada_usuario) / float(self.qtd_original_carteira)) * float(self.valor_original_item)
        return 0
    
    @property 
    def valor_restante(self):
        """Valor da quantidade restante"""
        if self.valor_original_item and self.qtd_original_carteira:
            return (float(self.qtd_restante_calculada) / float(self.qtd_original_carteira)) * float(self.valor_original_item)
        return 0
        
    @property
    def peso_selecionado(self):
        """Peso da quantidade selecionada"""
        if self.peso_original_item and self.qtd_original_carteira:
            return (float(self.qtd_selecionada_usuario) / float(self.qtd_original_carteira)) * float(self.peso_original_item)
        return 0
        
    @property
    def percentual_selecionado(self):
        """Percentual selecionado do total"""
        if self.qtd_original_carteira:
            return (float(self.qtd_selecionada_usuario) / float(self.qtd_original_carteira)) * 100
        return 0
    
    # ===== M√âTODOS DE NEG√ìCIO =====
    
    def gerar_hash_item(self, carteira_item):
        """Gera hash do item para detectar mudan√ßas"""
        dados = f"{carteira_item.num_pedido}|{carteira_item.cod_produto}|{carteira_item.qtd_saldo_produto_pedido}|{carteira_item.preco_produto_pedido}"
        return hashlib.md5(dados.encode()).hexdigest()
    
    def validar_quantidades(self):
        """Valida se quantidades s√£o consistentes"""
        if float(self.qtd_selecionada_usuario) > float(self.qtd_original_carteira):
            raise ValueError("Quantidade selecionada n√£o pode ser maior que a original")
        
        if float(self.qtd_restante_calculada) != (float(self.qtd_original_carteira) - float(self.qtd_selecionada_usuario)):
            self.qtd_restante_calculada = float(self.qtd_original_carteira) - float(self.qtd_selecionada_usuario)
    
    def marcar_como_recomposto(self, usuario):
        """Marca item como recomposto ap√≥s sincroniza√ß√£o Odoo"""
        self.recomposto = True
        self.data_recomposicao = datetime.utcnow()
        self.recomposto_por = usuario
        self.status = 'RECOMPOSTO'
    
    def recompor_na_carteira(self, carteira_item, usuario):
        """Recomp√µe divis√£o na carteira ap√≥s reimporta√ß√£o Odoo"""
        try:
            # Verificar se hash mudou (item foi alterado)
            novo_hash = self.gerar_hash_item(carteira_item)
            
            if self.hash_item_original != novo_hash:
                logger.warning(f"Item {self.num_pedido}-{self.cod_produto} foi alterado no Odoo")
            
            # Aplicar divis√£o na carteira
            if float(self.qtd_selecionada_usuario) < float(carteira_item.qtd_saldo_produto_pedido):
                # Criar nova linha com o saldo
                self._criar_linha_saldo_carteira(carteira_item)
                
                # Atualizar linha original
                carteira_item.qtd_saldo_produto_pedido = self.qtd_selecionada_usuario
                
                # Aplicar dados edit√°veis preservados
                if self.data_expedicao_editada:
                    carteira_item.expedicao = self.data_expedicao_editada
                if self.data_agendamento_editada:
                    carteira_item.agendamento = self.data_agendamento_editada  
                if self.protocolo_editado:
                    carteira_item.protocolo = self.protocolo_editado
                    
            # Marcar como recomposto
            self.marcar_como_recomposto(usuario)
            
            logger.info(f"‚úÖ Item {self.num_pedido}-{self.cod_produto} recomposto com sucesso")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao recompor item {self.num_pedido}-{self.cod_produto}: {e}")
            return False
    
    def _criar_linha_saldo_carteira(self, carteira_item):
        """Cria nova linha na carteira com saldo restante"""
        from .models import CarteiraPrincipal
        
                         # Criar nova linha copiando campos do item original
        nova_linha = CarteiraPrincipal()
        for column in CarteiraPrincipal.__table__.columns:
            if column.name not in ['id']:
                if hasattr(carteira_item, column.name):
                    setattr(nova_linha, column.name, getattr(carteira_item, column.name))
        
        # Sobrescrever quantidade com saldo restante
        nova_linha.qtd_saldo_produto_pedido = self.qtd_restante_calculada
        
        db.session.add(nova_linha)
        logger.info(f"‚ûï Criada linha com saldo: {self.qtd_restante_calculada}")
    
    # ===== M√âTODOS DE CLASSE (QUERIES) =====
    
    @classmethod
    def criar_pre_separacao(cls, carteira_item, qtd_selecionada, dados_editaveis, usuario, tipo_envio='total'):
        """Cria nova pr√©-separa√ß√£o"""
        
        # Calcular quantidades
        qtd_original = float(carteira_item.qtd_saldo_produto_pedido)
        qtd_selecionada = float(qtd_selecionada)
        qtd_restante = qtd_original - qtd_selecionada
        
        # Criar inst√¢ncia
        pre_separacao = cls(
            num_pedido=carteira_item.num_pedido,
            cod_produto=carteira_item.cod_produto,
            cnpj_cliente=carteira_item.cnpj_cliente,
            qtd_original_carteira=qtd_original,
            qtd_selecionada_usuario=qtd_selecionada,
            qtd_restante_calculada=qtd_restante,
            valor_original_item=carteira_item.preco_produto_pedido * qtd_original,
            peso_original_item=getattr(carteira_item, 'peso_total', 0),
            hash_item_original=cls().gerar_hash_item(carteira_item),
            data_expedicao_editada=dados_editaveis.get('data_expedicao'),
            data_agendamento_editada=dados_editaveis.get('data_agendamento'),
            protocolo_editado=dados_editaveis.get('protocolo'),
            observacoes_usuario=dados_editaveis.get('observacoes'),
            tipo_envio=tipo_envio,
            criado_por=usuario,
            status='CRIADO'
        )
        
        # Validar e salvar
        pre_separacao.validar_quantidades()
        db.session.add(pre_separacao)
        
        return pre_separacao
    
    @classmethod
    def buscar_nao_recompostas(cls):
        """Busca pr√©-separa√ß√µes que precisam ser recompostas ap√≥s Odoo"""
        return cls.query.filter(cls.recomposto == False).all()
    
    @classmethod  
    def buscar_por_pedido(cls, num_pedido):
        """Busca pr√©-separa√ß√µes de um pedido espec√≠fico"""
        return cls.query.filter(cls.num_pedido == num_pedido).all()
    
    @classmethod
    def recompor_todas_pendentes(cls, usuario):
        """Recomp√µe todas as pr√©-separa√ß√µes pendentes ap√≥s reimporta√ß√£o Odoo"""
        from .models import CarteiraPrincipal
        
        pendentes = cls.buscar_nao_recompostas()
        sucesso = 0
        erro = 0
        
        for pre_sep in pendentes:
            # Buscar item na carteira atual
            carteira_item = CarteiraPrincipal.query.filter(
                and_(
                    CarteiraPrincipal.num_pedido == pre_sep.num_pedido,
                    CarteiraPrincipal.cod_produto == pre_sep.cod_produto,
                    CarteiraPrincipal.cnpj_cliente == pre_sep.cnpj_cliente
                )
            ).first()
            
            if carteira_item:
                if pre_sep.recompor_na_carteira(carteira_item, usuario):
                    sucesso += 1
                else:
                    erro += 1
            else:
                logger.warning(f"Item {pre_sep.num_pedido}-{pre_sep.cod_produto} n√£o encontrado na carteira atual")
                erro += 1
        
        db.session.commit()
        
        logger.info(f"‚úÖ Recomposi√ß√£o conclu√≠da: {sucesso} sucessos, {erro} erros")
        return {'sucesso': sucesso, 'erro': erro, 'total': len(pendentes)}

    # ===== SISTEMA REAL DE PR√â-SEPARA√á√ÉO (TABELA PR√ìPRIA) =====
    
    @classmethod
    def criar_e_salvar(cls, carteira_item, qtd_selecionada, dados_editaveis, usuario, tipo_envio='total', config_parcial=None):
        """
        Cria e salva pr√©-separa√ß√£o na tabela real (p√≥s-migra√ß√£o UTF-8)
        """
        try:
            # Calcular quantidades
            qtd_original = float(carteira_item.qtd_saldo_produto_pedido or 0)
            qtd_selecionada = float(qtd_selecionada)
            qtd_restante = qtd_original - qtd_selecionada
            
            # Criar inst√¢ncia
            pre_separacao = cls()
            pre_separacao.num_pedido = carteira_item.num_pedido
            pre_separacao.cod_produto = carteira_item.cod_produto
            pre_separacao.cnpj_cliente = carteira_item.cnpj_cpf
            pre_separacao.nome_produto = carteira_item.nome_produto
            pre_separacao.qtd_original_carteira = qtd_original
            pre_separacao.qtd_selecionada_usuario = qtd_selecionada
            pre_separacao.qtd_restante_calculada = qtd_restante
            pre_separacao.valor_original_item = float(carteira_item.preco_produto_pedido or 0) * qtd_original
            pre_separacao.peso_original_item = float(getattr(carteira_item, 'peso', 0) or 0)
            pre_separacao.hash_item_original = cls._gerar_hash_item(carteira_item)
            pre_separacao.data_expedicao_editada = dados_editaveis.get('expedicao')
            pre_separacao.data_agendamento_editada = dados_editaveis.get('agendamento')
            pre_separacao.protocolo_editado = dados_editaveis.get('protocolo')
            pre_separacao.observacoes_usuario = dados_editaveis.get('observacoes')
            pre_separacao.tipo_envio = tipo_envio
            pre_separacao.criado_por = usuario
            pre_separacao.status = 'CRIADO'
            
            # Adicionar configura√ß√£o de envio parcial se necess√°rio
            if tipo_envio == 'parcial' and config_parcial:
                observacoes_parcial = f"ENVIO PARCIAL - Motivo: {config_parcial.get('motivo', 'N/A')} | " \
                                    f"Justificativa: {config_parcial.get('justificativa', 'N/A')} | " \
                                    f"Previs√£o Complemento: {config_parcial.get('previsao_complemento', 'N/A')} | " \
                                    f"Respons√°vel: {config_parcial.get('responsavel_aprovacao', 'N/A')}"
                
                if pre_separacao.observacoes_usuario:
                    pre_separacao.observacoes_usuario += f"\n{observacoes_parcial}"
                else:
                    pre_separacao.observacoes_usuario = observacoes_parcial
            
            # Validar e salvar
            pre_separacao.validar_quantidades()
            db.session.add(pre_separacao)
            db.session.commit()
            
            logger.info(f"‚úÖ Pr√©-separa√ß√£o criada com sucesso: {pre_separacao.num_pedido}-{pre_separacao.cod_produto}")
            return pre_separacao
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao criar pr√©-separa√ß√£o: {e}")
            db.session.rollback()
            raise
    
    @classmethod
    def _gerar_hash_item(cls, carteira_item):
        """Gera hash do item para detectar mudan√ßas"""
        dados = f"{carteira_item.num_pedido}|{carteira_item.cod_produto}|{carteira_item.qtd_saldo_produto_pedido}|{carteira_item.preco_produto_pedido}"
        return hashlib.md5(dados.encode()).hexdigest()
    
    @classmethod
    def buscar_por_pedido_produto(cls, num_pedido, cod_produto=None):
        """Busca pr√©-separa√ß√µes de um pedido espec√≠fico"""
        query = cls.query.filter(cls.num_pedido == num_pedido)
        if cod_produto:
            query = query.filter(cls.cod_produto == cod_produto)
        return query.all()
    
    @classmethod
    def criar_e_salvar(cls, carteira_item, qtd_selecionada, dados_editaveis, usuario, tipo_envio, config_parcial=None):
        """
        Cria e salva pr√©-separa√ß√£o (M√âTODO AUSENTE IMPLEMENTADO)
        Este m√©todo era chamado na linha 1559 do routes.py mas n√£o existia
        """
        try:
            # Validar disponibilidade
            if float(qtd_selecionada) > float(carteira_item.qtd_saldo_produto_pedido or 0):
                raise ValueError(f"Quantidade indispon√≠vel. Dispon√≠vel: {carteira_item.qtd_saldo_produto_pedido}")            
            # Criar pr√©-separa√ß√£o
            pre_separacao = cls()
            pre_separacao.num_pedido = carteira_item.num_pedido
            pre_separacao.cod_produto = carteira_item.cod_produto
            pre_separacao.cnpj_cliente = carteira_item.cnpj_cpf
            pre_separacao.qtd_original_carteira = carteira_item.qtd_saldo_produto_pedido
            pre_separacao.qtd_selecionada_usuario = qtd_selecionada
            pre_separacao.qtd_restante_calculada = carteira_item.qtd_saldo_produto_pedido - qtd_selecionada
            
            # Dados edit√°veis
            pre_separacao.data_expedicao_editada = dados_editaveis.get('expedicao')
            pre_separacao.data_agendamento_editada = dados_editaveis.get('agendamento') 
            pre_separacao.protocolo_editado = dados_editaveis.get('protocolo')
            pre_separacao.observacoes_usuario = dados_editaveis.get('observacoes')
            
            # Controle
            pre_separacao.tipo_envio = tipo_envio
            pre_separacao.status = 'CRIADO'
            pre_separacao.criado_por = usuario
            pre_separacao.hash_item_original = cls._gerar_hash_item(carteira_item)
            
            # Salvar
            db.session.add(pre_separacao)
            db.session.flush()  # Para obter ID
            
            logger.info(f"‚úÖ Pr√©-separa√ß√£o criada: {pre_separacao.id}")
            return pre_separacao
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao criar pr√©-separa√ß√£o: {e}")
            raise