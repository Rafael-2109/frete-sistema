"""
üí™ MODO ILIMITADO DO CLAUDE AI
Funcionalidades sem limita√ß√µes para m√°xima capacidade
"""

import os
import re
import ast
import json
from typing import Dict, List, Any, Optional
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

class UnlimitedClaudeMode:
    """Modo ilimitado com capacidades expandidas"""
    
    def __init__(self, app_path: Optional[str] = None):
        self.app_path = Path(app_path) if app_path else Path(__file__).parent.parent
        self.unlimited_active = True
        logger.info("üí™ Modo Ilimitado ativado!")
    
    def read_entire_project(self) -> Dict[str, Any]:
        """L√™ o projeto INTEIRO sem limita√ß√µes"""
        project_data = {
            'files': {},
            'structure': {},
            'total_files': 0,
            'total_lines': 0,
            'total_size_mb': 0
        }
        
        try:
            for root, dirs, files in os.walk(self.app_path):
                # N√£o filtrar diret√≥rios - ler TUDO
                for file in files:
                    if file.endswith(('.py', '.html', '.js', '.css', '.md', '.txt', '.json', '.yml', '.yaml')):
                        file_path = Path(root) / file
                        rel_path = file_path.relative_to(self.app_path)
                        
                        try:
                            content = file_path.read_text(encoding='utf-8')
                            project_data['files'][str(rel_path)] = {
                                'content': content,  # Conte√∫do COMPLETO
                                'lines': len(content.split('\n')),
                                'size_kb': len(content) / 1024,
                                'type': file_path.suffix
                            }
                            
                            project_data['total_files'] += 1
                            project_data['total_lines'] += len(content.split('\n'))
                            project_data['total_size_mb'] += len(content) / (1024 * 1024)
                            
                        except Exception as e:
                            logger.warning(f"Erro ao ler {file_path}: {e}")
            
            logger.info(f"üí™ Projeto COMPLETO lido: {project_data['total_files']} arquivos, "
                       f"{project_data['total_lines']} linhas, {project_data['total_size_mb']:.2f}MB")
            
            return project_data
            
        except Exception as e:
            logger.error(f"Erro na leitura ilimitada: {e}")
            return project_data
    
    def analyze_unlimited_patterns(self, project_data: Dict) -> Dict[str, Any]:
        """Analisa padr√µes sem limita√ß√£o de complexidade"""
        patterns = {
            'code_patterns': [],
            'architectural_patterns': [],
            'data_flow_patterns': [],
            'security_patterns': [],
            'performance_patterns': []
        }
        
        try:
            for file_path, file_info in project_data['files'].items():
                if file_path.endswith('.py'):
                    content = file_info['content']
                    
                    # An√°lise AST completa
                    try:
                        tree = ast.parse(content)
                        
                        # Analisar TODOS os n√≥s, n√£o apenas alguns
                        for node in ast.walk(tree):
                            # Classes
                            if isinstance(node, ast.ClassDef):
                                patterns['architectural_patterns'].append({
                                    'type': 'class_definition',
                                    'name': node.name,
                                    'file': file_path,
                                    'methods': [n.name for n in node.body if isinstance(n, ast.FunctionDef)],
                                    'inheritance': [base.id for base in node.bases if hasattr(base, 'id')]
                                })
                            
                            # Fun√ß√µes
                            elif isinstance(node, ast.FunctionDef):
                                patterns['code_patterns'].append({
                                    'type': 'function_definition',
                                    'name': node.name,
                                    'file': file_path,
                                    'args': len(node.args.args),
                                    'decorators': [d.id for d in node.decorator_list if hasattr(d, 'id')]
                                })
                            
                            # Imports
                            elif isinstance(node, ast.Import):
                                for alias in node.names:
                                    patterns['data_flow_patterns'].append({
                                        'type': 'import',
                                        'module': alias.name,
                                        'file': file_path
                                    })
                    
                    except Exception as e:
                        logger.warning(f"Erro na an√°lise AST de {file_path}: {e}")
            
            logger.info(f"üí™ An√°lise ilimitada conclu√≠da: {len(patterns['code_patterns'])} padr√µes encontrados")
            return patterns
            
        except Exception as e:
            logger.error(f"Erro na an√°lise ilimitada: {e}")
            return patterns
    
    def generate_unlimited_insights(self, patterns: Dict) -> List[str]:
        """Gera insights sem limita√ß√£o de profundidade"""
        insights = []
        
        try:
            # An√°lise de arquitetura
            classes = [p for p in patterns['architectural_patterns'] if p['type'] == 'class_definition']
            functions = [p for p in patterns['code_patterns'] if p['type'] == 'function_definition']
            imports = [p for p in patterns['data_flow_patterns'] if p['type'] == 'import']
            
            # Insights arquiteturais
            if len(classes) > 50:
                insights.append(f"üèóÔ∏è Arquitetura robusta: {len(classes)} classes encontradas - sistema bem estruturado")
            
            if len(functions) > 200:
                insights.append(f"‚öôÔ∏è Sistema complexo: {len(functions)} fun√ß√µes - alta funcionalidade")
            
            # An√°lise de padr√µes MVC
            mvc_files = [f for f in patterns['architectural_patterns'] if any(keyword in f.get('file', '') for keyword in ['models', 'views', 'controllers', 'routes'])]
            if mvc_files:
                insights.append(f"üéØ Padr√£o MVC detectado: {len(mvc_files)} componentes arquiteturais")
            
            # An√°lise de depend√™ncias
            unique_modules = set(p['module'] for p in imports)
            if len(unique_modules) > 20:
                insights.append(f"üì¶ Sistema rico em depend√™ncias: {len(unique_modules)} m√≥dulos √∫nicos")
            
            # An√°lise de complexidade
            total_methods = sum(len(c.get('methods', [])) for c in classes)
            if total_methods > 100:
                insights.append(f"üß† Alta complexidade: {total_methods} m√©todos distribu√≠dos")
            
            logger.info(f"üí™ Insights ilimitados gerados: {len(insights)} descobertas")
            return insights
            
        except Exception as e:
            logger.error(f"Erro na gera√ß√£o de insights: {e}")
            return insights
    
    def unlimited_code_analysis(self, file_content: str, file_path: str) -> Dict[str, Any]:
        """An√°lise de c√≥digo sem limita√ß√µes"""
        analysis = {
            'complexity_score': 0,
            'maintainability_score': 0,
            'security_issues': [],
            'performance_issues': [],
            'suggestions': [],
            'detailed_metrics': {}
        }
        
        try:
            lines = file_content.split('\n')
            
            # M√©tricas detalhadas
            analysis['detailed_metrics'] = {
                'total_lines': len(lines),
                'code_lines': len([l for l in lines if l.strip() and not l.strip().startswith('#')]),
                'comment_lines': len([l for l in lines if l.strip().startswith('#')]),
                'blank_lines': len([l for l in lines if not l.strip()]),
                'avg_line_length': sum(len(l) for l in lines) / len(lines) if lines else 0
            }
            
            # An√°lise de complexidade (sem limites)
            if file_path.endswith('.py'):
                try:
                    tree = ast.parse(file_content)
                    
                    complexity = 0
                    for node in ast.walk(tree):
                        if isinstance(node, (ast.If, ast.For, ast.While, ast.With, ast.Try)):
                            complexity += 1
                        elif isinstance(node, ast.FunctionDef):
                            complexity += 2
                        elif isinstance(node, ast.ClassDef):
                            complexity += 3
                    
                    analysis['complexity_score'] = complexity
                    
                    # Score de manutenibilidade
                    analysis['maintainability_score'] = max(0, 100 - (complexity * 2))
                    
                except Exception as e:
                    logger.warning(f"Erro na an√°lise AST: {e}")
            
            # Detec√ß√£o de problemas de seguran√ßa (expandida)
            security_patterns = [
                ('eval(', 'Uso de eval() - risco de execu√ß√£o de c√≥digo'),
                ('exec(', 'Uso de exec() - risco de execu√ß√£o de c√≥digo'),
                ('subprocess.call', 'Chamada de subprocess - verificar entrada'),
                ('os.system', 'Uso de os.system - risco de inje√ß√£o'),
                ('sql.*%', 'Poss√≠vel SQL injection'),
                (r'password.*=.*["\']', 'Password hardcoded'),
                (r'api_key.*=.*["\']', 'API key hardcoded')
            ]
            
            for pattern, description in security_patterns:
                if re.search(pattern, file_content, re.IGNORECASE):
                    analysis['security_issues'].append(description)
            
            # Detec√ß√£o de problemas de performance
            performance_patterns = [
                (r'for.*in.*query\.all\(\)', 'Query em loop - usar select_related'),
                (r'time\.sleep', 'Sleep em c√≥digo - pode afetar performance'),
                (r'print\(', 'Print em c√≥digo de produ√ß√£o'),
                (r'\.filter\(.*\)\.filter\(', 'M√∫ltiplos filters - considerar combinar')
            ]
            
            for pattern, description in performance_patterns:
                if re.search(pattern, file_content, re.IGNORECASE):
                    analysis['performance_issues'].append(description)
            
            # Sugest√µes de melhoria (expandidas)
            if analysis['complexity_score'] > 50:
                analysis['suggestions'].append('Considere refatorar - complexidade alta')
            
            if analysis['detailed_metrics']['avg_line_length'] > 120:
                analysis['suggestions'].append('Linhas muito longas - considere quebrar')
            
            if analysis['detailed_metrics']['comment_lines'] < analysis['detailed_metrics']['code_lines'] * 0.1:
                analysis['suggestions'].append('Adicionar mais coment√°rios - documenta√ß√£o baixa')
            
            logger.info(f"üí™ An√°lise ilimitada de {file_path}: complexidade {analysis['complexity_score']}")
            return analysis
            
        except Exception as e:
            logger.error(f"Erro na an√°lise ilimitada: {e}")
            return analysis

# Inst√¢ncia global
unlimited_mode = None

def get_unlimited_mode() -> UnlimitedClaudeMode:
    """Retorna inst√¢ncia do modo ilimitado"""
    global unlimited_mode
    if unlimited_mode is None:
        unlimited_mode = UnlimitedClaudeMode()
    return unlimited_mode

def activate_unlimited_mode() -> bool:
    """Ativa modo ilimitado"""
    try:
        mode = get_unlimited_mode()
        logger.info("üí™ Modo Ilimitado ATIVADO - Capacidades expandidas!")
        return True
    except Exception as e:
        logger.error(f"Erro ao ativar modo ilimitado: {e}")
        return False
