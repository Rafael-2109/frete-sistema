from app import db
#!/usr/bin/env python3
"""
ü§ñ SISTEMA MULTI-AGENT AI - POTENCIAL M√ÅXIMO
Sistema de m√∫ltiplos agentes especializados com valida√ß√£o cruzada
"""

import logging
import asyncio
from typing import Dict, List, Any, Optional
from datetime import datetime
import json
from enum import Enum

logger = logging.getLogger(__name__)

class AgentType(Enum):
    """Tipos de agentes especializados"""
    ENTREGAS = "entregas"
    FRETES = "fretes" 
    PEDIDOS = "pedidos"
    EMBARQUES = "embarques"
    FINANCEIRO = "financeiro"
    CRITIC = "critic"
    VALIDATOR = "validator"

class SpecialistAgent:
    """Agente especialista em um dom√≠nio espec√≠fico"""
    
    def __init__(self, agent_type: AgentType, claude_client=None):
        self.agent_type = agent_type
        self.claude_client = claude_client
        self.specialist_prompt = self._load_specialist_prompt()
        self.knowledge_base = self._load_domain_knowledge()
        
    def _load_specialist_prompt(self) -> str:
        """Carrega system prompt especializado para o dom√≠nio"""
        
        prompts = {
            AgentType.ENTREGAS: """
üöö AGENTE ESPECIALISTA EM ENTREGAS

Voc√™ √© um especialista em monitoramento e gest√£o de entregas. Sua expertise inclui:

**DOM√çNIO DE CONHECIMENTO:**
- Entregas monitoradas e status de finaliza√ß√£o
- Agendamentos e reagendamentos
- Prazos, atrasos e pontualidade
- Transportadoras e motoristas
- Problemas de entrega e solu√ß√µes
- Pend√™ncias financeiras relacionadas a entregas

**DADOS QUE VOC√ä ANALISA:**
- EntregaMonitorada: status_finalizacao, data_entrega_prevista, data_hora_entrega_realizada
- AgendamentoEntrega: protocolo_agendamento, status, data_agendada
- Transportadoras e performance de entrega

**SUA ESPECIALIDADE:**
- Calcular pontualidade e KPIs de entrega
- Identificar padr√µes de atraso
- Analisar performance por transportadora
- Detectar problemas operacionais
- Sugerir otimiza√ß√µes de processo

**SEMPRE RESPONDA:**
1. Com foco espec√≠fico em ENTREGAS
2. Baseado em dados reais do sistema
3. Com m√©tricas de performance
4. Com sugest√µes pr√°ticas para melhorias
""",
            
            AgentType.FRETES: """
üöõ AGENTE ESPECIALISTA EM FRETES

Voc√™ √© um especialista em gest√£o de fretes e custos log√≠sticos. Sua expertise inclui:

**DOM√çNIO DE CONHECIMENTO:**
- Cota√ß√µes de frete e tabelas de pre√ßo
- Aprova√ß√µes e pagamentos de frete  
- CTEs e documenta√ß√£o fiscal
- Despesas extras e multas
- Performance financeira de transportadoras
- An√°lise de custos log√≠sticos

**DADOS QUE VOC√ä ANALISA:**
- Frete: valor_frete, status_aprovacao, numero_cte
- DespesaExtra: tipo_despesa, valor_despesa
- Transportadora: performance de custo
- Tabelas de frete e modalidades

**SUA ESPECIALIDADE:**
- Analisar custos e rentabilidade de fretes
- Identificar oportunidades de economia
- Monitorar performance financeira
- Detectar anomalias em custos
- Otimizar sele√ß√£o de transportadoras

**SEMPRE RESPONDA:**
1. Com foco espec√≠fico em FRETES e CUSTOS
2. Com an√°lise financeira detalhada
3. Com comparativos de performance
4. Com sugest√µes de otimiza√ß√£o de custo
""",
            
            AgentType.PEDIDOS: """
üìã AGENTE ESPECIALISTA EM PEDIDOS

Voc√™ √© um especialista em gest√£o de pedidos e fluxo comercial. Sua expertise inclui:

**DOM√çNIO DE CONHECIMENTO:**
- Status de pedidos e faturamento
- Cota√ß√µes e aprova√ß√µes comerciais
- Agendamentos e protocolos
- Separa√ß√£o e expedi√ß√£o
- Clientes e vendedores

**DADOS QUE VOC√ä ANALISA:**
- Pedido: status_calculado, valor_saldo_total, agendamento
- Separa√ß√£o e itens por produto
- Relacionamento com embarques
- Performance por cliente/vendedor

**SUA ESPECIALIDADE:**
- Analisar carteira de pedidos
- Identificar gargalos no processo
- Monitorar performance comercial
- Detectar pedidos pendentes
- Otimizar fluxo de separa√ß√£o

**SEMPRE RESPONDA:**
1. Com foco espec√≠fico em PEDIDOS
2. Com an√°lise do pipeline comercial
3. Com m√©tricas de convers√£o
4. Com sugest√µes de melhoria operacional
""",
            
            AgentType.CRITIC: """
üîç AGENTE CR√çTICO - VALIDADOR CRUZADO

Voc√™ √© um agente cr√≠tico que valida consist√™ncia entre especialistas. Sua fun√ß√£o √©:

**RESPONSABILIDADES:**
1. Analisar respostas dos agentes especialistas
2. Identificar inconsist√™ncias entre dom√≠nios
3. Validar dados cruzados entre modelos
4. Detectar contradi√ß√µes l√≥gicas
5. Sugerir corre√ß√µes ou esclarecimentos

**CRIT√âRIOS DE VALIDA√á√ÉO:**
- Consist√™ncia temporal (datas coerentes)
- Consist√™ncia de dados (valores batem)
- L√≥gica de neg√≥cio (fluxo correto)
- Completude da informa√ß√£o
- Qualidade da resposta

**FORMATO DE RESPOSTA:**
```json
{
    "validation_score": 0.85,
    "inconsistencies": ["Agent Fretes menciona data X, Agent Entregas menciona data Y"],
    "recommendations": ["Verificar data real no banco"],
    "approval": true/false
}
```
""",
            
            AgentType.VALIDATOR: """
‚öñÔ∏è VALIDADOR FINAL - CONVERG√äNCIA

Voc√™ √© o validador final que consolida todas as an√°lises. Sua fun√ß√£o √©:

**RESPONSABILIDADES:**
1. Receber an√°lises de todos os especialistas
2. Receber valida√ß√£o do agente cr√≠tico
3. Convergir informa√ß√µes em resposta final
4. Calcular score de confian√ßa geral
5. Produzir resposta consolidada e precisa

**PROCESSO DE CONVERG√äNCIA:**
1. Priorizar informa√ß√µes validadas pelo cr√≠tico
2. Resolver conflitos usando dados mais recentes
3. Integrar insights de m√∫ltiplos dom√≠nios
4. Adicionar contexto cruzado quando relevante
5. Produzir resposta coerente e completa

**FORMATO FINAL:**
- Resposta consolidada natural
- Score de confian√ßa
- Fontes de dados utilizadas
- Alertas se houver incertezas
"""
        }
        
        return prompts.get(self.agent_type, "")
    
    def _load_domain_knowledge(self) -> Dict[str, Any]:
        """Carrega conhecimento espec√≠fico do dom√≠nio"""
        
        # Buscar conhecimento espec√≠fico baseado no README
        knowledge = {
            AgentType.ENTREGAS: {
                'main_models': ['EntregaMonitorada', 'AgendamentoEntrega'],
                'key_fields': ['status_finalizacao', 'data_entrega_prevista', 'data_hora_entrega_realizada'],
                'kpis': ['pontualidade', 'taxa_entrega', 'tempo_medio_entrega'],
                'common_queries': ['entregas atrasadas', 'performance transportadora', 'agendamentos']
            },
            AgentType.FRETES: {
                'main_models': ['Frete', 'DespesaExtra', 'Transportadora'],
                'key_fields': ['valor_frete', 'status_aprovacao', 'numero_cte'],
                'kpis': ['custo_por_kg', 'performance_financeira', 'economia_frete'],
                'common_queries': ['custos frete', 'aprova√ß√µes pendentes', 'despesas extras']
            },
            AgentType.PEDIDOS: {
                'main_models': ['Pedido', 'Separacao'],
                'key_fields': ['status_calculado', 'valor_saldo_total', 'agendamento'],
                'kpis': ['taxa_conversao', 'tempo_separacao', 'valor_medio_pedido'],
                'common_queries': ['pedidos pendentes', 'carteira cliente', 'separa√ß√£o atrasada']
            }
        }
        
        return knowledge.get(self.agent_type, {})
    
    async def analyze(self, query: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """Analisa consulta espec√≠fica do dom√≠nio"""
        
        try:
            # Verificar se a consulta √© relevante para este dom√≠nio
            relevance_score = self._calculate_relevance(query)
            
            if relevance_score < 0.3:
                return {
                    'agent': self.agent_type.value,
                    'relevance': relevance_score,
                    'response': None,
                    'reasoning': f'Consulta n√£o relevante para dom√≠nio {self.agent_type.value}'
                }
            
            # Processar consulta com especializa√ß√£o
            response = await self._process_specialized_query(query, context)
            
            return {
                'agent': self.agent_type.value,
                'relevance': relevance_score,
                'response': response,
                'confidence': self._calculate_confidence(response),
                'timestamp': datetime.now().isoformat(),
                'reasoning': f'An√°lise especializada em {self.agent_type.value}'
            }
            
        except Exception as e:
            logger.error(f"Erro no agente {self.agent_type.value}: {e}")
            return {
                'agent': self.agent_type.value,
                'error': str(e),
                'response': None
            }
    
    def _calculate_relevance(self, query: str) -> float:
        """Calcula relev√¢ncia da consulta para este dom√≠nio"""
        
        query_lower = query.lower()
        
        domain_keywords = {
            AgentType.ENTREGAS: [
                'entrega', 'entregue', 'transportadora', 'motorista', 'agendamento',
                'protocolo', 'atraso', 'prazo', 'pontualidade', 'canhoto', 'destinat√°rio'
            ],
            AgentType.FRETES: [
                'frete', 'valor', 'custo', 'aprova√ß√£o', 'cte', 'pagamento',
                'despesa', 'multa', 'transportadora', 'cota√ß√£o', 'tabela'  
            ],
            AgentType.PEDIDOS: [
                'pedido', 'separa√ß√£o', 'cota√ß√£o', 'cliente', 'vendedor',
                'expedi√ß√£o', 'status', 'carteira', 'valor', 'produto'
            ]
        }
        
        keywords = domain_keywords.get(self.agent_type, [])
        matches = sum(1 for keyword in keywords if keyword in query_lower)
        
        return min(matches / len(keywords), 1.0) if keywords else 0.0
    
    async def _process_specialized_query(self, query: str, context: Dict[str, Any]) -> str:
        """Processa consulta com especializa√ß√£o de dom√≠nio"""
        
        if not self.claude_client:
            return f"An√°lise simulada do agente {self.agent_type.value} para: {query}"
        
        # Construir mensagem especializada
        specialized_message = f"""
CONSULTA ESPECIALIZADA EM {self.agent_type.value.upper()}:

Consulta do usu√°rio: {query}

Contexto dispon√≠vel:
{json.dumps(context, indent=2, ensure_ascii=False)}

Conhecimento espec√≠fico do dom√≠nio:
{json.dumps(self.knowledge_base, indent=2, ensure_ascii=False)}

Por favor, forne√ßa an√°lise especializada focada exclusivamente no seu dom√≠nio de expertise.
"""
        
        try:
            response = self.claude_client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=2000,
                temperature=0.1,
                system=self.specialist_prompt,
                messages=[{"role": "user", "content": specialized_message}]
            )
            
            return response.content[0].text
            
        except Exception as e:
            logger.error(f"Erro no Claude para agente {self.agent_type.value}: {e}")
            return f"Erro na an√°lise especializada: {str(e)}"
    
    def _calculate_confidence(self, response: str) -> float:
        """Calcula score de confian√ßa da resposta"""
        
        if not response or 'erro' in response.lower():
            return 0.0
        
        # Fatores que aumentam confian√ßa
        confidence_factors = [
            len(response) > 100,  # Resposta substancial
            'dados' in response.lower(),  # Menciona dados
            any(field in response.lower() for field in self.knowledge_base.get('key_fields', [])),
            'an√°lise' in response.lower(),  # Faz an√°lise
            not ('n√£o encontrado' in response.lower())  # Encontrou dados
        ]
        
        return sum(confidence_factors) / len(confidence_factors)

class CriticAgent:
    """Agente cr√≠tico que valida consist√™ncia entre especialistas"""
    
    def __init__(self, claude_client=None):
        self.claude_client = claude_client
        self.validation_rules = self._load_validation_rules()
    
    def _load_validation_rules(self) -> List[Dict[str, Any]]:
        """Carrega regras de valida√ß√£o cruzada"""
        
        return [
            {
                'rule': 'data_consistency',
                'description': 'Datas mencionadas devem ser coerentes entre agentes',
                'validators': ['date_logic', 'timeline_consistency']
            },
            {
                'rule': 'value_consistency', 
                'description': 'Valores financeiros devem bater entre dom√≠nios',
                'validators': ['value_cross_check', 'calculation_verification']
            },
            {
                'rule': 'business_logic',
                'description': 'L√≥gica de neg√≥cio deve ser respeitada',
                'validators': ['workflow_validation', 'status_progression']
            }
        ]
    
    async def validate_responses(self, agent_responses: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Valida consist√™ncia entre respostas dos agentes"""
        
        validation_result = {
            'validation_score': 1.0,
            'inconsistencies': [],
            'recommendations': [],
            'approval': True,
            'cross_validation': {}
        }
        
        # Filtrar apenas respostas v√°lidas
        valid_responses = [r for r in agent_responses if r.get('response')]
        
        if len(valid_responses) < 2:
            validation_result['recommendations'].append("Apenas um agente respondeu - valida√ß√£o cruzada limitada")
            return validation_result
        
        # Validar consist√™ncia temporal
        date_consistency = self._validate_date_consistency(valid_responses)
        validation_result['cross_validation']['dates'] = date_consistency
        
        # Validar consist√™ncia de dados
        data_consistency = self._validate_data_consistency(valid_responses)
        validation_result['cross_validation']['data'] = data_consistency
        
        # Calcular score geral
        consistency_scores = [date_consistency.get('score', 1.0), data_consistency.get('score', 1.0)]
        validation_result['validation_score'] = sum(consistency_scores) / len(consistency_scores)
        
        # Determinar aprova√ß√£o
        validation_result['approval'] = validation_result['validation_score'] >= 0.7
        
        return validation_result
    
    def _validate_date_consistency(self, responses: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Valida consist√™ncia de datas entre respostas"""
        
        # Extrair datas mencionadas nas respostas
        mentioned_dates = []
        for response in responses:
            text = response.get('response', '')
            # Regex simples para encontrar datas
            import re
            dates = re.findall(r'\d{1,2}/\d{1,2}/\d{4}', text)
            mentioned_dates.extend([(response['agent'], date) for date in dates])
        
        # Analisar consist√™ncia
        inconsistencies = []
        if len(set(date for _, date in mentioned_dates)) > len(mentioned_dates) * 0.5:
            inconsistencies.append("Muitas datas diferentes mencionadas entre agentes")
        
        return {
            'score': 1.0 - (len(inconsistencies) * 0.3),
            'inconsistencies': inconsistencies,
            'dates_found': mentioned_dates
        }
    
    def _validate_data_consistency(self, responses: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Valida consist√™ncia de dados entre respostas"""
        
        inconsistencies = []
        
        # Verificar se agentes mencionam dados conflitantes
        response_texts = [r.get('response', '') for r in responses]
        
        # An√°lise simples de conflitos
        if any('n√£o encontrado' in text.lower() for text in response_texts) and \
           any('encontrado' in text.lower() and 'n√£o encontrado' not in text.lower() for text in response_texts):
            inconsistencies.append("Conflito: alguns agentes encontraram dados, outros n√£o")
        
        return {
            'score': 1.0 - (len(inconsistencies) * 0.2),
            'inconsistencies': inconsistencies
        }

class MultiAgentSystem:
    """Sistema principal de m√∫ltiplos agentes"""
    
    def __init__(self, claude_client=None):
        self.claude_client = claude_client
        
        # Inicializar agentes especialistas
        self.agents = {
            AgentType.ENTREGAS: SpecialistAgent(AgentType.ENTREGAS, claude_client),
            AgentType.FRETES: SpecialistAgent(AgentType.FRETES, claude_client),
            AgentType.PEDIDOS: SpecialistAgent(AgentType.PEDIDOS, claude_client),
        }
        
        # Agente cr√≠tico
        self.critic = CriticAgent(claude_client)
        
        # Hist√≥rico de opera√ß√µes
        self.operation_history = []
        
    async def process_query(self, query: str, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Processa consulta usando sistema multi-agente"""
        
        start_time = datetime.now()
        operation_id = f"op_{start_time.strftime('%Y%m%d_%H%M%S')}"
        
        logger.info(f"üöÄ Multi-Agent System processando: {query[:50]}...")
        
        context = context or {}
        
        try:
            # FASE 1: An√°lise paralela por agentes especialistas
            logger.info("üìä FASE 1: An√°lise por agentes especialistas")
            
            tasks = []
            for agent_type, agent in self.agents.items():
                task = agent.analyze(query, context)
                tasks.append(task)
            
            agent_responses = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Filtrar respostas v√°lidas
            valid_responses = []
            for response in agent_responses:
                if isinstance(response, dict) and not response.get('error'):
                    valid_responses.append(response)
                else:
                    logger.warning(f"Resposta inv√°lida de agente: {response}")
            
            # FASE 2: Valida√ß√£o cr√≠tica
            logger.info("üîç FASE 2: Valida√ß√£o cr√≠tica")
            
            validation_result = await self.critic.validate_responses(valid_responses)
            
            # FASE 3: Converg√™ncia final
            logger.info("‚öñÔ∏è FASE 3: Converg√™ncia final")
            
            final_response = await self._converge_responses(query, valid_responses, validation_result)
            
            # Registrar opera√ß√£o
            operation_record = {
                'operation_id': operation_id,
                'query': query,
                'timestamp': start_time.isoformat(),
                'duration_seconds': (datetime.now() - start_time).total_seconds(),
                'agent_responses': valid_responses,
                'validation': validation_result,
                'final_response': final_response,
                'success': True
            }
            
            self.operation_history.append(operation_record)
            
            return {
                'success': True,
                'operation_id': operation_id,
                'response': final_response,
                'metadata': {
                    'agents_used': len(valid_responses),
                    'validation_score': validation_result.get('validation_score', 0),
                    'processing_time': (datetime.now() - start_time).total_seconds(),
                    'consistency_check': validation_result.get('approval', False)
                },
                'debug_info': {
                    'agent_responses': valid_responses,
                    'validation_details': validation_result
                } if context.get('debug', False) else None
            }
            
        except Exception as e:
            logger.error(f"‚ùå Erro no Multi-Agent System: {e}")
            
            return {
                'success': False,
                'error': str(e),
                'operation_id': operation_id,
                'response': f"Erro no processamento multi-agente: {str(e)}"
            }
    
    async def _converge_responses(self, query: str, agent_responses: List[Dict[str, Any]], 
                                validation_result: Dict[str, Any]) -> str:
        """Converge respostas dos agentes em resposta final"""
        
        if not agent_responses:
            return "Nenhum agente conseguiu processar a consulta adequadamente."
        
        # Selecionar respostas mais relevantes
        relevant_responses = [r for r in agent_responses if r.get('relevance', 0) > 0.5]
        
        if not relevant_responses:
            relevant_responses = agent_responses  # Fallback
        
        # Ordenar por relev√¢ncia e confian√ßa
        relevant_responses.sort(key=lambda x: (x.get('relevance', 0) + x.get('confidence', 0)) / 2, reverse=True)
        
        # Construir resposta convergente
        main_response = "Resposta n√£o dispon√≠vel"
        convergence_note = ""
        
        if len(relevant_responses) == 1:
            # Uma resposta dominante
            main_response = relevant_responses[0].get('response') or "Resposta n√£o dispon√≠vel"
            agent_name = relevant_responses[0].get('agent', 'desconhecido')
            convergence_note = f"\n\n---\nü§ñ **An√°lise:** Resposta do agente especialista em {agent_name}"
        else:
            # M√∫ltiplas respostas - convergir
            main_agent = relevant_responses[0]
            secondary_agents = relevant_responses[1:]
            
            main_response = main_agent.get('response') or "Resposta n√£o dispon√≠vel"
            
            # Adicionar insights de outros agentes se relevantes
            additional_insights = []
            for agent in secondary_agents:
                if agent.get('confidence', 0) > 0.6 and agent.get('response'):
                    response_text = agent.get('response', "Sem resposta")
                    agent_name = agent.get('agent', 'desconhecido')
                    additional_insights.append(f"**{agent_name.title()}:** {response_text[:200]}...")
            
            main_agent_name = main_agent.get('agent', 'desconhecido')
            main_agent_relevance = main_agent.get('relevance', 0)
            
            convergence_note = f"\n\n---\nü§ñ **An√°lise Multi-Agente:**\n"
            convergence_note += f"**Principal:** {main_agent_name.title()} (relev√¢ncia: {main_agent_relevance:.1f})\n"
            
            if additional_insights:
                # Filtrar insights v√°lidos e garantir que n√£o sejam None
                valid_insights = [insight for insight in additional_insights if insight and isinstance(insight, str)]
                if valid_insights:
                    convergence_note += f"**Insights complementares:**\n" + "\n".join(valid_insights)
        
        # Adicionar valida√ß√£o
        validation_note = ""
        validation_score = validation_result.get('validation_score', 1)
        if validation_score < 0.8:
            validation_note = f"\n‚ö†Ô∏è **Nota:** Valida√ß√£o cruzada detectou poss√≠veis inconsist√™ncias (score: {validation_score:.2f})"
        
        # Construir resposta final - PROTE√á√ÉO ABSOLUTA CONTRA None
        # Prote√ß√£o absoluta contra None
        main_response = main_response or "Resposta n√£o dispon√≠vel"
        convergence_note = convergence_note or ""
        validation_note = validation_note or ""
        
        final_response = str(main_response) + str(convergence_note) + str(validation_note)
        
        return final_response
    
    def get_system_stats(self) -> Dict[str, Any]:
        """Retorna estat√≠sticas do sistema multi-agente"""
        
        if not self.operation_history:
            return {"message": "Nenhuma opera√ß√£o realizada ainda"}
        
        total_ops = len(self.operation_history)
        avg_time = sum(op['duration_seconds'] for op in self.operation_history) / total_ops
        success_rate = sum(1 for op in self.operation_history if op['success']) / total_ops
        
        agent_usage = {}
        for op in self.operation_history:
            for response in op.get('agent_responses', []):
                agent = response.get('agent', 'unknown')
                agent_usage[agent] = agent_usage.get(agent, 0) + 1
        
        return {
            'total_operations': total_ops,
            'success_rate': success_rate,
            'average_processing_time': avg_time,
            'agent_usage_stats': agent_usage,
            'last_operation': self.operation_history[-1]['timestamp']
        }

# Inst√¢ncia global
multi_agent_system = None

def get_multi_agent_system(claude_client=None) -> MultiAgentSystem:
    """Retorna inst√¢ncia do sistema multi-agente"""
    global multi_agent_system
    
    if multi_agent_system is None:
        multi_agent_system = MultiAgentSystem(claude_client)
        logger.info("üöÄ Multi-Agent System inicializado")
    
    return multi_agent_system 