#!/usr/bin/env python3
"""
üéØ IMPLEMENTA√á√ÉO DO ORCHESTRATOR INTEGRADO
==========================================

Script para implementar as conex√µes entre m√≥dulos atrav√©s do Orchestrator.
"""

import os
import sys
import logging
from typing import Dict, Any, Optional

# Adicionar o diret√≥rio raiz ao path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../..')))

# Configurar logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
logger = logging.getLogger(__name__)

def implementar_fase1_scanner_loader():
    """FASE 1: Conectar Scanner ‚Üí Loader"""
    logger.info("\nüîß FASE 1: Conectando Scanner ‚Üí Loader")
    
    try:
        # 1. Verificar se Scanner tem m√©todo get_database_info
        scanner_manager_path = "scanning/scanning_manager.py"
        logger.info(f"üìÑ Verificando {scanner_manager_path}...")
        
        with open(scanner_manager_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        if "def get_database_info" not in content:
            logger.info("‚ùå M√©todo get_database_info n√£o existe no ScanningManager")
            logger.info("‚úÖ Adicionando m√©todo...")
            
            # Adicionar m√©todo
            method_code = '''
    def get_database_info(self) -> Dict[str, Any]:
        """Retorna informa√ß√µes descobertas para outros m√≥dulos"""
        try:
            if not self.database_scanner:
                self.initialize_database_scanner()
                
            return {
                'tables': self.database_scanner.get_tables() if hasattr(self.database_scanner, 'get_tables') else {},
                'indexes': self.database_scanner.get_indexes() if hasattr(self.database_scanner, 'get_indexes') else {},
                'relationships': self.database_scanner.get_relationships() if hasattr(self.database_scanner, 'get_relationships') else {},
                'statistics': self.database_scanner.get_statistics() if hasattr(self.database_scanner, 'get_statistics') else {}
            }
        except Exception as e:
            logger.warning(f"Erro ao obter informa√ß√µes do banco: {e}")
            return {'tables': {}, 'indexes': {}, 'relationships': {}, 'statistics': {}}
'''
            
            # Encontrar onde inserir (antes do √∫ltimo m√©todo ou no final da classe)
            import_pos = content.rfind("def ")
            if import_pos > 0:
                # Voltar para o in√≠cio da linha
                import_pos = content.rfind('\n', 0, import_pos) + 1
                new_content = content[:import_pos] + method_code + '\n' + content[import_pos:]
            else:
                # Adicionar antes do final da classe
                class_end = content.rfind('\n\n')
                new_content = content[:class_end] + method_code + content[class_end:]
                
            with open(scanner_manager_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
                
            logger.info("‚úÖ M√©todo get_database_info adicionado ao ScanningManager")
        else:
            logger.info("‚úÖ M√©todo get_database_info j√° existe")
            
        # 2. Modificar LoaderManager para usar Scanner
        loader_manager_path = "loaders/loader_manager.py"
        logger.info(f"\nüìÑ Modificando {loader_manager_path}...")
        
        with open(loader_manager_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        if "self.scanner = " not in content:
            logger.info("‚ùå LoaderManager n√£o est√° conectado ao Scanner")
            logger.info("‚úÖ Adicionando conex√£o...")
            
            # Adicionar import
            if "from app.claude_ai_novo.scanning import get_scanning_manager" not in content:
                import_pos = content.find("logger = logging.getLogger(__name__)")
                if import_pos > 0:
                    import_pos = content.find('\n', import_pos) + 1
                    content = content[:import_pos] + "\nfrom app.claude_ai_novo.scanning import get_scanning_manager\n" + content[import_pos:]
            
            # Modificar __init__
            init_pos = content.find("def __init__(self):")
            if init_pos > 0:
                # Encontrar o final do __init__ atual
                init_end = content.find("self._initialize_loaders()", init_pos)
                if init_end > 0:
                    # Adicionar antes de _initialize_loaders
                    scanner_code = """
        # Conectar com Scanner para otimiza√ß√£o
        try:
            self.scanner = get_scanning_manager()
            self.db_info = self.scanner.get_database_info()
            logger.info("‚úÖ LoaderManager conectado ao Scanner")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Scanner n√£o dispon√≠vel: {e}")
            self.scanner = None
            self.db_info = {'tables': {}, 'indexes': {}, 'relationships': {}}
            
"""
                    content = content[:init_end] + scanner_code + "        " + content[init_end:]
                    
            with open(loader_manager_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
            logger.info("‚úÖ LoaderManager conectado ao Scanner")
        else:
            logger.info("‚úÖ LoaderManager j√° est√° conectado ao Scanner")
            
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Erro na Fase 1: {e}")
        return False

def implementar_fase2_mapper_loader():
    """FASE 2: Conectar Mapper ‚Üí Loader"""
    logger.info("\nüîß FASE 2: Conectando Mapper ‚Üí Loader")
    
    try:
        # Modificar um loader de dom√≠nio como exemplo
        entregas_loader_path = "loaders/domain/entregas_loader.py"
        logger.info(f"üìÑ Modificando {entregas_loader_path}...")
        
        with open(entregas_loader_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        if "self.mapper = " not in content:
            logger.info("‚ùå EntregasLoader n√£o est√° conectado ao Mapper")
            logger.info("‚úÖ Adicionando conex√£o...")
            
            # Adicionar import
            if "from app.claude_ai_novo.mappers import get_semantic_mapper" not in content:
                import_pos = content.find("logger = logging.getLogger(__name__)")
                if import_pos > 0:
                    import_pos = content.find('\n', import_pos) + 1
                    content = content[:import_pos] + "\nfrom app.claude_ai_novo.mappers import get_semantic_mapper\n" + content[import_pos:]
            
            # Modificar __init__
            init_pos = content.find("def __init__(self):")
            if init_pos > 0:
                init_end = content.find("logger.info", init_pos)
                if init_end > 0:
                    mapper_code = """
        # Conectar com Mapper para mapeamento sem√¢ntico
        try:
            self.mapper = get_semantic_mapper()
            self.field_map = self.mapper.get_mapping('entregas')
            logger.info("‚úÖ EntregasLoader conectado ao Mapper")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Mapper n√£o dispon√≠vel: {e}")
            self.mapper = None
            self.field_map = {}
            
"""
                    content = content[:init_end] + mapper_code + "        " + content[init_end:]
                    
            with open(entregas_loader_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
            logger.info("‚úÖ EntregasLoader conectado ao Mapper")
        else:
            logger.info("‚úÖ EntregasLoader j√° est√° conectado ao Mapper")
            
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Erro na Fase 2: {e}")
        return False

def implementar_fase3_loader_provider():
    """FASE 3: Eliminar duplica√ß√£o Loader ‚Üî Provider"""
    logger.info("\nüîß FASE 3: Conectando Provider ‚Üí Loader (eliminar duplica√ß√£o)")
    
    try:
        provider_path = "providers/data_provider.py"
        logger.info(f"üìÑ Refatorando {provider_path}...")
        
        with open(provider_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        if "self.loader = " not in content:
            logger.info("‚ùå DataProvider n√£o est√° usando LoaderManager")
            logger.info("‚úÖ Refatorando para usar LoaderManager...")
            
            # Adicionar import
            if "from app.claude_ai_novo.loaders import get_loader_manager" not in content:
                import_pos = content.find("logger = logging.getLogger(__name__)")
                if import_pos > 0:
                    import_pos = content.find('\n', import_pos) + 1
                    content = content[:import_pos] + "\nfrom app.claude_ai_novo.loaders import get_loader_manager\n" + content[import_pos:]
            
            # Modificar __init__
            init_pos = content.find("def __init__(self):")
            if init_pos > 0:
                init_end = content.find("logger.info", init_pos)
                if init_end > 0:
                    loader_code = """
        # Usar LoaderManager ao inv√©s de queries diretas
        try:
            self.loader = get_loader_manager()
            logger.info("‚úÖ DataProvider conectado ao LoaderManager")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è LoaderManager n√£o dispon√≠vel: {e}")
            self.loader = None
            
"""
                    content = content[:init_end] + loader_code + "        " + content[init_end:]
                    
            # Refatorar get_data_by_domain para usar loader
            method_pos = content.find("def get_data_by_domain(self, domain: str")
            if method_pos > 0:
                # Encontrar o in√≠cio do m√©todo
                method_start = content.find("{", method_pos)
                method_end = content.find("return {", method_pos)
                
                if method_start > 0 and method_end > 0:
                    new_method = '''
        """Obt√©m dados por dom√≠nio usando LoaderManager"""
        try:
            # Delegar para LoaderManager ao inv√©s de duplicar l√≥gica
            if self.loader:
                logger.info(f"üìä Usando LoaderManager para dom√≠nio: {domain}")
                result = self.loader.load_data_by_domain(domain, filters)
                
                # Adicionar metadados se necess√°rio
                if result and 'data' in result:
                    result['source'] = 'loader_manager'
                    result['optimized'] = True
                    
                return result
            else:
                # Fallback para implementa√ß√£o atual se loader n√£o dispon√≠vel
                logger.warning("‚ö†Ô∏è LoaderManager n√£o dispon√≠vel, usando fallback")
'''
                    # Manter o resto do m√©todo como fallback
                    
            with open(provider_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
            logger.info("‚úÖ DataProvider refatorado para usar LoaderManager")
        else:
            logger.info("‚úÖ DataProvider j√° est√° usando LoaderManager")
            
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Erro na Fase 3: {e}")
        return False

def validar_conexoes():
    """Valida se as conex√µes foram estabelecidas corretamente"""
    logger.info("\nüîç Validando conex√µes estabelecidas...")
    
    try:
        # Testar importa√ß√µes
        from app.claude_ai_novo.scanning import get_scanning_manager
        from app.claude_ai_novo.loaders import get_loader_manager
        from app.claude_ai_novo.providers import get_data_provider
        
        # Testar Scanner ‚Üí Loader
        logger.info("\nüìä Testando Scanner ‚Üí Loader...")
        loader = get_loader_manager()
        if hasattr(loader, 'scanner'):
            logger.info("‚úÖ LoaderManager tem acesso ao Scanner")
        else:
            logger.warning("‚ùå LoaderManager n√£o tem acesso ao Scanner")
            
        # Testar Provider ‚Üí Loader
        logger.info("\nüìä Testando Provider ‚Üí Loader...")
        provider = get_data_provider()
        if hasattr(provider, 'loader'):
            logger.info("‚úÖ DataProvider usa LoaderManager")
        else:
            logger.warning("‚ùå DataProvider n√£o usa LoaderManager")
            
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Erro na valida√ß√£o: {e}")
        return False

def main():
    """Executa a implementa√ß√£o do Orchestrator Integrado"""
    logger.info("üéØ INICIANDO IMPLEMENTA√á√ÉO DO ORCHESTRATOR INTEGRADO")
    logger.info("=" * 60)
    
    # Fase 1: Scanner ‚Üí Loader
    if implementar_fase1_scanner_loader():
        logger.info("‚úÖ Fase 1 conclu√≠da com sucesso")
    else:
        logger.error("‚ùå Fase 1 falhou")
        return
        
    # Fase 2: Mapper ‚Üí Loader
    if implementar_fase2_mapper_loader():
        logger.info("‚úÖ Fase 2 conclu√≠da com sucesso")
    else:
        logger.error("‚ùå Fase 2 falhou")
        return
        
    # Fase 3: Loader ‚Üí Provider
    if implementar_fase3_loader_provider():
        logger.info("‚úÖ Fase 3 conclu√≠da com sucesso")
    else:
        logger.error("‚ùå Fase 3 falhou")
        return
        
    # Validar conex√µes
    logger.info("\n" + "=" * 60)
    if validar_conexoes():
        logger.info("\n‚úÖ IMPLEMENTA√á√ÉO CONCLU√çDA COM SUCESSO!")
        logger.info("\nüìä Pr√≥ximos passos:")
        logger.info("1. Testar o sistema com consultas reais")
        logger.info("2. Implementar Fase 4: Memorizer ‚Üí Processor")
        logger.info("3. Implementar Fase 5: Learner ‚Üí Analyzer")
    else:
        logger.error("\n‚ùå Valida√ß√£o falhou - verificar implementa√ß√£o")

if __name__ == "__main__":
    main() 