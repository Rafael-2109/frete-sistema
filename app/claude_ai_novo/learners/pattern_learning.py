"""
üéØ PATTERN LEARNER - Aprendizado de Padr√µes
==========================================

M√≥dulo especializado em detectar, extrair e salvar padr√µes
de comportamento e linguagem natural dos usu√°rios.

Responsabilidades:
- Extra√ß√£o de padr√µes de consultas
- Detec√ß√£o de inten√ß√µes
- Aprendizado de vocabul√°rio
- An√°lise sem√¢ntica b√°sica
"""

import json
import logging
from datetime import datetime
from typing import Dict, List, Any, Optional
try:
    from flask import current_app
    FLASK_AVAILABLE = True
except ImportError:
    current_app = None
    FLASK_AVAILABLE = False
from app.claude_ai_novo.utils.flask_fallback import get_db

logger = logging.getLogger(__name__)

class PatternLearner:

    @property
    def db(self):
        """Obt√©m db com fallback"""
        if not hasattr(self, "_db"):
            self._db = get_db()
        return self._db

    """
    Especialista em aprendizado de padr√µes comportamentais e lingu√≠sticos.
    
    Detecta padr√µes nas consultas dos usu√°rios e aprende com eles
    para melhorar futuras interpreta√ß√µes.
    """
    
    def __init__(self, learning_rate: float = 0.1):
        """
        Inicializa o aprendiz de padr√µes.
        
        Args:
            learning_rate: Taxa de aprendizado (0-1)
        """
        self.learning_rate = learning_rate
        logger.info("üéØ PatternLearner inicializado")
    
    def extrair_e_salvar_padroes(self, consulta: str, interpretacao: Dict[str, Any]) -> List[Dict]:
        """
        Extrai padr√µes da consulta e salva no banco.
        
        Args:
            consulta: Consulta do usu√°rio
            interpretacao: Interpreta√ß√£o gerada pelo sistema
            
        Returns:
            Lista de padr√µes detectados e salvos
        """
        try:
            padroes_detectados = []
            
            # 1. Extrair diferentes tipos de padr√µes
            padroes_extraidos = self._extrair_padroes_multipos(consulta, interpretacao)
            
            # 2. Salvar cada padr√£o no banco
            for padrao in padroes_extraidos:
                padrao_salvo = self._salvar_padrao_otimizado(padrao)
                if padrao_salvo:
                    padroes_detectados.append(padrao_salvo)
            
            logger.debug(f"üéØ Extra√≠dos {len(padroes_detectados)} padr√µes da consulta")
            return padroes_detectados
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao extrair padr√µes: {e}")
            return []
    
    def _extrair_padroes_multipos(self, consulta: str, interpretacao: Dict[str, Any]) -> List[Dict]:
        """
        Extrai m√∫ltiplos tipos de padr√µes da consulta.
        
        Args:
            consulta: Consulta original
            interpretacao: Interpreta√ß√£o do sistema
            
        Returns:
            Lista de padr√µes extra√≠dos
        """
        padroes = []
        
        # 1. Padr√µes de per√≠odo temporal
        padroes.extend(self._extrair_padroes_periodo(consulta, interpretacao))
        
        # 2. Padr√µes de dom√≠nio/contexto
        padroes.extend(self._extrair_padroes_dominio(consulta, interpretacao))
        
        # 3. Padr√µes de inten√ß√£o/a√ß√£o
        padroes.extend(self._extrair_padroes_intencao(consulta, interpretacao))
        
        # 4. Padr√µes de entidades (clientes, produtos, etc.)
        padroes.extend(self._extrair_padroes_entidades(consulta, interpretacao))
        
        # 5. Padr√µes de estrutura lingu√≠stica
        padroes.extend(self._extrair_padroes_linguisticos(consulta, interpretacao))
        
        return padroes
    
    def _extrair_padroes_periodo(self, consulta: str, interpretacao: Dict) -> List[Dict]:
        """Extrai padr√µes relacionados a per√≠odo temporal"""
        padroes = []
        
        if interpretacao.get("periodo_dias"):
            consulta_lower = consulta.lower()
            
            # Detectar express√µes temporais
            expressoes_temporais = [
                ("√∫ltimos", "ultimos"), ("√∫ltima", "ultima"), 
                ("ontem", "hoje"), ("semana", "m√™s"), ("dias", "dia")
            ]
            
            for expr_grupo in expressoes_temporais:
                for expr in expr_grupo:
                    if expr in consulta_lower:
                        padroes.append({
                            "tipo": "periodo_temporal",
                            "texto": expr,
                            "interpretacao": {
                                "periodo_dias": interpretacao["periodo_dias"],
                                "expressao_detectada": expr
                            },
                            "contexto": consulta,
                            "confianca": 0.8
                        })
                        break  # N√£o duplicar para sin√¥nimos
        
        return padroes
    
    def _extrair_padroes_dominio(self, consulta: str, interpretacao: Dict) -> List[Dict]:
        """Extrai padr√µes relacionados ao dom√≠nio/√°rea de neg√≥cio"""
        padroes = []
        
        if interpretacao.get("dominio"):
            dominio = interpretacao["dominio"]
            palavras_chave = self._extrair_palavras_chave_dominio(consulta, dominio)
            
            for palavra in palavras_chave:
                padroes.append({
                    "tipo": "dominio_negocio",
                    "texto": palavra,
                    "interpretacao": {
                        "dominio": dominio,
                        "palavra_chave": palavra
                    },
                    "contexto": consulta,
                    "confianca": 0.7
                })
        
        return padroes
    
    def _extrair_padroes_intencao(self, consulta: str, interpretacao: Dict) -> List[Dict]:
        """Extrai padr√µes de inten√ß√£o do usu√°rio"""
        padroes = []
        
        # Detectar inten√ß√£o automaticamente
        intencao_info = self._detectar_intencao_avancada(consulta)
        
        if intencao_info:
            padroes.append({
                "tipo": "intencao_usuario",
                "texto": intencao_info["trigger"],
                "interpretacao": {
                    "intencao": intencao_info["tipo"],
                    "confianca_deteccao": intencao_info["confianca"]
                },
                "contexto": consulta,
                "confianca": intencao_info["confianca"]
            })
        
        return padroes
    
    def _extrair_padroes_entidades(self, consulta: str, interpretacao: Dict) -> List[Dict]:
        """Extrai padr√µes de entidades nomeadas (clientes, produtos, etc.)"""
        padroes = []
        
        # Padr√£o de cliente espec√≠fico
        if interpretacao.get("cliente_especifico"):
            cliente = interpretacao["cliente_especifico"]
            termos_cliente = self._extrair_termos_cliente(consulta, cliente)
            
            for termo in termos_cliente:
                padroes.append({
                    "tipo": "entidade_cliente",
                    "texto": termo,
                    "interpretacao": {
                        "cliente_oficial": cliente,
                        "termo_usado": termo
                    },
                    "contexto": consulta,
                    "confianca": 0.9  # Alta confian√ßa para clientes
                })
        
        # Padr√£o de localiza√ß√£o/UF
        if interpretacao.get("uf_especifica"):
            uf = interpretacao["uf_especifica"]
            padroes.append({
                "tipo": "entidade_localizacao",
                "texto": uf,
                "interpretacao": {
                    "uf": uf,
                    "tipo_entidade": "estado"
                },
                "contexto": consulta,
                "confianca": 0.8
            })
        
        return padroes
    
    def _extrair_padroes_linguisticos(self, consulta: str, interpretacao: Dict) -> List[Dict]:
        """Extrai padr√µes de estrutura lingu√≠stica"""
        padroes = []
        
        # Padr√µes de pergunta
        if consulta.strip().endswith('?'):
            tipo_pergunta = self._classificar_tipo_pergunta(consulta)
            padroes.append({
                "tipo": "estrutura_pergunta",
                "texto": tipo_pergunta["palavra_chave"],
                "interpretacao": {
                    "tipo_pergunta": tipo_pergunta["tipo"],
                    "estrutura": "interrogativa"
                },
                "contexto": consulta,
                "confianca": 0.6
            })
        
        # Padr√µes de comando/solicita√ß√£o
        verbos_comando = ["mostre", "liste", "gere", "exporte", "busque", "encontre"]
        consulta_lower = consulta.lower()
        
        for verbo in verbos_comando:
            if verbo in consulta_lower:
                padroes.append({
                    "tipo": "estrutura_comando",
                    "texto": verbo,
                    "interpretacao": {
                        "verbo_comando": verbo,
                        "estrutura": "imperativa"
                    },
                    "contexto": consulta,
                    "confianca": 0.7
                })
                break  # Apenas um verbo comando por consulta
        
        return padroes
    
    def _salvar_padrao_otimizado(self, padrao: Dict) -> Optional[Dict]:
        """
        Salva ou atualiza um padr√£o no banco com otimiza√ß√µes.
        
        Args:
            padrao: Padr√£o a ser salvo
            
        Returns:
            Padr√£o salvo ou None se erro
        """
        try:
            with current_app.app_context():
                from app.claude_ai_novo.utils.flask_fallback import get_db
        except Exception as e:
            logger.error(f'Erro: {e}')
            pass
try:
    from sqlalchemy import text
    SQLALCHEMY_AVAILABLE = True
except ImportError:
    text = None
    SQLALCHEMY_AVAILABLE = False
                
                # Verificar se j√° existe
                existe = self.db.session.execute(
                    text("""
                        SELECT id, confidence, usage_count, success_rate
                        FROM ai_knowledge_patterns
                        WHERE pattern_type = :tipo AND pattern_text = :texto
                    """),
                    {"tipo": padrao["tipo"], "texto": padrao["texto"]}
                ).fetchone()
                
                if existe:
                    # Atualizar existente
                    self.db.session.execute(
                        text("""
                            UPDATE ai_knowledge_patterns
                            SET confidence = :conf, usage_count = usage_count + 1,
                                updated_at = CURRENT_TIMESTAMP
                            WHERE id = :id
                        """),
                        {"conf": padrao["confidence"], "id": existe[0]}
                    )
                else:
                    # Inserir novo
                    result = self.db.session.execute(
                        text("""
                            INSERT INTO ai_knowledge_patterns
                            (pattern_type, pattern_text, confidence, usage_count, 
                             success_rate, metadata)
                            VALUES (:tipo, :texto, :conf, 1, 0.7, :meta)
                            RETURNING id
                        """),
                        {
                            "tipo": padrao["tipo"],
                            "texto": padrao["texto"],
                            "conf": padrao["confidence"],
                            "meta": self._safe_json_dumps(padrao.get("metadata", {}))
                        }
                    )
                    row = result.fetchone()
                    if row:
                        padrao["id"] = row[0]
                
                self.db.session.commit()
                return padrao
                
        except Exception as e:
            logger.error(f"Erro ao salvar padr√£o: {e}")
            try:
                from app.claude_ai_novo.utils.flask_fallback import get_db
                self.db.session.rollback()
            except:
                pass
    
    def buscar_padroes_aplicaveis(self, consulta: str, threshold: float = 0.5) -> List[Dict]:
        """
        Busca padr√µes aplic√°veis a uma consulta.
        
        Args:
            consulta: Consulta a ser analisada
            threshold: Threshold m√≠nimo de confian√ßa
            
        Returns:
            Lista de padr√µes aplic√°veis
        """
        try:
            with current_app.app_context():
                from app.claude_ai_novo.utils.flask_fallback import get_db
        except Exception as e:
            logger.error(f'Erro: {e}')
            pass
try:
    from sqlalchemy import text
    SQLALCHEMY_AVAILABLE = True
except ImportError:
    text = None
    SQLALCHEMY_AVAILABLE = False
                
                padroes = self.db.session.execute(
                    text("""
                        SELECT pattern_type, pattern_text, interpretation, confidence, usage_count
                        FROM ai_knowledge_patterns
                        WHERE confidence > :threshold
                        AND LOWER(:consulta) LIKE '%' || LOWER(pattern_text) || '%'
                        ORDER BY confidence DESC, usage_count DESC
                        LIMIT 10
                    """),
                    {"consulta": consulta, "threshold": threshold}
                ).fetchall()
                
                padroes_aplicaveis = []
                for padrao in padroes:
                    # Fazer parse seguro da interpreta√ß√£o
                    try:
                        if isinstance(padrao.interpretation, str):
                            interpretacao = json.loads(padrao.interpretation)
                        else:
                            # J√° √© um dict, usar diretamente
                            interpretacao = padrao.interpretation
                    except (json.JSONDecodeError, TypeError) as e:
                        logger.warning(f"‚ö†Ô∏è Erro ao fazer parse da interpreta√ß√£o: {e}")
                        interpretacao = {}
                    
                    padroes_aplicaveis.append({
                        "tipo": padrao.pattern_type,
                        "texto": padrao.pattern_text,
                        "interpretacao": interpretacao,
                        "confianca": padrao.confidence,
                        "uso_count": padrao.usage_count
                    })
                
                return padroes_aplicaveis
                
        except Exception as e:
            logger.error(f"‚ùå Erro ao buscar padr√µes: {e}")
            return []
    
    def _extrair_palavras_chave_dominio(self, texto: str, dominio: str) -> List[str]:
        """Extrai palavras-chave relevantes para o dom√≠nio"""
        palavras = texto.lower().split()
        palavras_relevantes = []
        
        # Vocabul√°rio por dom√≠nio
        vocabulario_dominio = {
            "entregas": ["entrega", "entregue", "prazo", "atraso", "monitoramento", "pendente"],
            "fretes": ["frete", "cte", "valor", "aprova√ß√£o", "transportadora", "aprovado"],
            "pedidos": ["pedido", "cotar", "aberto", "faturado", "embarque", "separa√ß√£o"],
            "financeiro": ["pagar", "pago", "fatura", "cobran√ßa", "vencimento", "pend√™ncia"]
        }
        
        vocab = vocabulario_dominio.get(dominio, [])
        for palavra in palavras:
            if palavra in vocab:
                palavras_relevantes.append(palavra)
        
        return list(set(palavras_relevantes))  # Remove duplicatas
    
    def _detectar_intencao_avancada(self, consulta: str) -> Optional[Dict]:
        """Detecta inten√ß√£o da consulta com an√°lise avan√ßada"""
        consulta_lower = consulta.lower()
        
        # Padr√µes de inten√ß√£o mais refinados
        intencoes = {
            "consultar_status": {
                "triggers": ["qual", "como est√°", "status", "situa√ß√£o", "onde est√°"],
                "confianca": 0.8
            },
            "listar_itens": {
                "triggers": ["liste", "mostre", "quais s√£o", "todos", "todas as"],
                "confianca": 0.9
            },
            "comparar_dados": {
                "triggers": ["compare", "diferen√ßa", "versus", "vs", "melhor", "pior"],
                "confianca": 0.7
            },
            "exportar_dados": {
                "triggers": ["excel", "planilha", "exportar", "relat√≥rio", "gerar", "baixar"],
                "confianca": 0.9
            },
            "analisar_tendencias": {
                "triggers": ["an√°lise", "tend√™ncia", "padr√£o", "estat√≠stica", "evolu√ß√£o"],
                "confianca": 0.8
            },
            "buscar_informacao": {
                "triggers": ["buscar", "encontrar", "procurar", "localizar", "descobrir"],
                "confianca": 0.7
            }
        }
        
        # Encontrar melhor match
        melhor_match = None
        melhor_confianca = 0
        
        for intencao, config in intencoes.items():
            for trigger in config["triggers"]:
                if trigger in consulta_lower:
                    confianca = config["confianca"]
                    # Bonus por trigger mais espec√≠fico (palavras maiores)
                    if len(trigger) > 5:
                        confianca += 0.1
                    
                    if confianca > melhor_confianca:
                        melhor_confianca = confianca
                        melhor_match = {
                            "tipo": intencao,
                            "trigger": trigger,
                            "confianca": min(1.0, confianca)
                        }
        
        return melhor_match
    
    def _extrair_termos_cliente(self, consulta: str, cliente: str) -> List[str]:
        """Extrai termos usados para referenciar um cliente"""
        termos = []
        consulta_lower = consulta.lower()
        cliente_lower = cliente.lower()
        
        # Nome completo
        if cliente_lower in consulta_lower:
            termos.append(cliente_lower)
        
        # Palavras individuais do nome do cliente
        palavras_cliente = cliente_lower.split()
        for palavra in palavras_cliente:
            if len(palavra) > 2 and palavra in consulta_lower:
                termos.append(palavra)
        
        # Abrevia√ß√µes e varia√ß√µes
        palavras_consulta = consulta_lower.split()
        for palavra in palavras_consulta:
            if len(palavra) > 2:
                # Verificar se palavra est√° contida no nome do cliente
                if palavra in cliente_lower or cliente_lower.startswith(palavra):
                    termos.append(palavra)
        
        return list(set(termos))  # Remove duplicatas
    
    def _classificar_tipo_pergunta(self, consulta: str) -> Dict[str, str]:
        """Classifica o tipo de pergunta baseado na estrutura"""
        consulta_lower = consulta.lower()
        
        # Palavras interrogativas
        tipos_pergunta = {
            "qual": "especificacao",
            "quais": "listagem", 
            "quanto": "quantidade",
            "quando": "temporal",
            "onde": "localizacao",
            "como": "processo",
            "por que": "causa",
            "porque": "causa",
            "quem": "responsavel"
        }
        
        for palavra, tipo in tipos_pergunta.items():
            if palavra in consulta_lower:
                return {"tipo": tipo, "palavra_chave": palavra}
        
        # Default para perguntas sem palavra interrogativa clara
        return {"tipo": "generica", "palavra_chave": "?"}

    def _safe_json_dumps(self, obj: Any) -> str:
        """
        Safely dumps an object to JSON, handling potential errors.
        Returns an empty string on error.
        """
        try:
            return json.dumps(obj, ensure_ascii=False, default=str)
        except Exception as e:
            logger.error(f"‚ùå Erro ao serializar JSON: {e}")
            return ""


# Singleton para uso global
_pattern_learner = None

def get_pattern_learner() -> PatternLearner:
    """
    Obt√©m inst√¢ncia √∫nica do aprendiz de padr√µes.
    
    Returns:
        Inst√¢ncia do PatternLearner
    """
    global _pattern_learner
    if _pattern_learner is None:
        _pattern_learner = PatternLearner()
    return _pattern_learner 