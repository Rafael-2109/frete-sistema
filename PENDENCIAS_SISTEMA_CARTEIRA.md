# üìã PEND√äNCIAS DO SISTEMA DE CARTEIRA DE PEDIDOS

## üéØ **RESUMO EXECUTIVO**

Ap√≥s an√°lise t√©cnica detalhada das 6 fun√ß√µes implementadas, foram identificadas **pend√™ncias cr√≠ticas** que impedem o funcionamento adequado do sistema. Este documento detalha cada problema encontrado e as solu√ß√µes necess√°rias.

## üìä **STATUS GERAL DO SISTEMA - ATUALIZADO 01/07/2025**

- **Implementado anteriormente:** 9 m√≥dulos, 55+ rotas, 27+ templates
- **Status atual:** Sistema funcional com primeira pend√™ncia cr√≠tica resolvida
- **Grau de implementa√ß√£o:** **80% operacional**, 20% necessita corre√ß√µes
- **√öltima corre√ß√£o:** Item 1 - Fun√ß√£o Baixa Autom√°tica de Faturamento ‚úÖ

---

## üö® **PEND√äNCIAS CR√çTICAS - ALTA PRIORIDADE**

### **‚úÖ 1. ‚ö†Ô∏è FUN√á√ÉO BAIXA AUTOM√ÅTICA DE FATURAMENTO - RESOLVIDO**

**Status:** **‚úÖ CORRIGIDO EM 01/07/2025**

**üîç PROBLEMA IDENTIFICADO (RESOLVIDO):**
```python
# ‚ùå IMPLEMENTA√á√ÉO INCORRETA (CORRIGIDA)
from app.faturamento.models import RelatorioFaturamentoImportado
itens_nf = RelatorioFaturamentoImportado.query.filter_by(numero_nf=numero_nf).all()

# ‚úÖ IMPLEMENTA√á√ÉO CORRETA (APLICADA)
from app.faturamento.models import FaturamentoProduto
itens_nf = FaturamentoProduto.query.filter_by(numero_nf=numero_nf, status_nf='ATIVO').all()
```

**üìã DETALHES T√âCNICOS (CORRIGIDOS):**
- **RelatorioFaturamentoImportado:** Cont√©m apenas dados gerais da NF (sem produtos)
- **FaturamentoProduto:** Cont√©m dados detalhados por produto (necess√°rio para baixa)
- **Campos corrigidos:** `qtd_produto_faturado` ao inv√©s de `qtd_faturada`

**üîß CORRE√á√ïES APLICADAS:**
1. **Tabela correta:** `FaturamentoProduto` ao inv√©s de `RelatorioFaturamentoImportado`
2. **Campos corretos:** Usando `qtd_produto_faturado`, `origem`, `status_nf`
3. **Valida√ß√£o melhorada:** Apenas NFs ativas (`status_nf='ATIVO'`)
4. **Error handling:** Mensagens mais espec√≠ficas e informativas
5. **Logs detalhados:** Identifica√ß√£o clara do problema e fonte de dados

**üìä TESTE/VALIDA√á√ÉO:**
- Fun√ß√£o agora usa a tabela correta com dados por produto
- Integra√ß√£o com CarteiraPrincipal via campo `origem` = `num_pedido`
- Detec√ß√£o de inconsist√™ncias funcional
- Sistema √† prova de erros com rollback

**Commit:** `92dc63f` - Aplicado com sucesso no GitHub/Render

---

### **2. ‚ùå BAIXA AUTOM√ÅTICA DE ESTOQUE N√ÉO IMPLEMENTADA**

**üîç PROBLEMA IDENTIFICADO:**
```python
# ‚ùå BAIXA APENAS NA CARTEIRA
item_carteira.qtd_saldo_produto_pedido -= qtd_a_baixar
item_copia.baixa_produto_pedido += qtd_a_baixar

# ‚ùå FALTANDO: BAIXA NO ESTOQUE F√çSICO
# N√ÉO h√° integra√ß√£o com MovimentacaoEstoque
```

**üìã IMPACTO OPERACIONAL:**
- **Carteira atualizada:** ‚úÖ Saldo correto na carteira
- **Estoque f√≠sico:** ‚ùå N√£o baixa automaticamente
- **Diverg√™ncias:** Sistema fica inconsistente
- **Controle:** Imposs√≠vel reconciliar estoque real vs carteira

**üîß IMPLEMENTA√á√ÉO NECESS√ÅRIA:**
```python
# ‚úÖ SOLU√á√ÉO PROPOSTA
def _baixar_estoque_automatico(cod_produto, qtd_baixada, numero_nf, usuario):
    from app.estoque.models import MovimentacaoEstoque
    
    movimentacao = MovimentacaoEstoque(
        cod_produto=cod_produto,
        qtd_movimentacao=-qtd_baixada,  # Negativo = sa√≠da
        tipo_movimentacao='FATURAMENTO',
        documento_origem=numero_nf,
        observacoes=f'Baixa autom√°tica NF {numero_nf}',
        criado_por=usuario
    )
    db.session.add(movimentacao)
```

---

### **3. ‚ùå SISTEMA DE ALERTAS/NOTIFICA√á√ïES INEXISTENTE**

**üîç PROBLEMA IDENTIFICADO:**
```python
# ‚ùå CAMPOS CRIADOS MAS SEM FUNCIONALIDADE
class SaldoStandby:
    data_limite_standby = db.Column(db.Date)
    proximo_alerta = db.Column(db.Date) 
    alertas_enviados = db.Column(db.Integer, default=0)

# ‚ùå N√ÉO EXISTE:
# - Dashboard para visualizar alertas
# - Job/cron para verificar prazos
# - Sistema de notifica√ß√£o (email/sistema)
```

**üîß IMPLEMENTA√á√ÉO NECESS√ÅRIA:**

#### **3.1 Dashboard de Saldos Standby**
```python
@carteira_bp.route('/dashboard-saldos-standby')
def dashboard_saldos_standby():
    # ‚ùå ROTA EXISTE MAS N√ÉO FUNCIONA
    # Template retorna erro ou dados vazios
```

#### **3.2 Sistema de Alertas Autom√°ticos**
```python
# ‚úÖ FUN√á√ÉO NECESS√ÅRIA
def verificar_alertas_vencidos():
    """Job di√°rio para verificar alertas vencidos"""
    from datetime import date
    
    saldos_vencidos = SaldoStandby.query.filter(
        SaldoStandby.proximo_alerta <= date.today(),
        SaldoStandby.status_standby == 'ATIVO'
    ).all()
    
    for saldo in saldos_vencidos:
        # Enviar notifica√ß√£o
        # Atualizar pr√≥ximo_alerta
        pass
```

#### **3.3 Interface de Notifica√ß√µes**
```html
<!-- ‚ùå N√ÉO EXISTE - NECESS√ÅRIO CRIAR -->
<div class="notifications-panel">
    <div class="alert alert-warning">
        <i class="fas fa-clock"></i>
        <strong>5 saldos</strong> vencendo hoje
    </div>
</div>
```

---

### **4. ‚ùå CONFIGURA√á√ïES DE TIPO CARGA LIMITADAS**

**üîç PROBLEMA IDENTIFICADO:**
```html
<!-- ‚ùå INTERFACE LIMITADA -->
<input type="radio" name="tipo_envio" value="TOTAL">
<input type="radio" name="tipo_envio" value="PARCIAL">

<!-- ‚ùå FALTANDO CAMPOS CR√çTICOS -->
<!-- Peso m√°ximo, pallets m√°ximos, valor m√°ximo -->
<!-- Toler√¢ncias de altera√ß√£o -->
<!-- Comportamentos espec√≠ficos -->
```

**üìã CAMPOS AUSENTES NO TEMPLATE:**
```html
<!-- ‚úÖ NECESS√ÅRIO ADICIONAR -->
<input type="number" name="capacidade_maxima_peso" placeholder="Peso m√°ximo (kg)">
<input type="number" name="capacidade_maxima_pallets" placeholder="Pallets m√°ximos">
<input type="number" name="capacidade_maxima_valor" placeholder="Valor m√°ximo (R$)">
<input type="number" name="tolerancia_alteracao" placeholder="% toler√¢ncia">
```

**üîß L√ìGICA FALTANDO:**
```python
# ‚ùå N√ÉO IMPLEMENTADO - NECESS√ÅRIO
def verificar_capacidade_carga(separacao_lote_id, nova_qtd):
    """Verifica se altera√ß√£o cabe na carga ou precisa nova"""
    tipo_carga = TipoCarga.query.filter_by(separacao_lote_id=separacao_lote_id).first()
    
    if tipo_carga.tipo_envio == 'PARCIAL':
        return False  # Sempre criar nova carga
    
    # Verificar limites de peso, pallets, valor
    if peso_novo > tipo_carga.capacidade_maxima_peso:
        return False
    
    return True
```

---

### **5. ‚ùå HIST√ìRICO DE JUSTIFICATIVAS N√ÉO FUNCIONAL**

**üîç PROBLEMA IDENTIFICADO:**
```html
<!-- ‚ùå TEMPLATE MOSTRA PLACEHOLDER -->
<tbody>
    <tr>
        <td colspan="9" class="text-center text-muted py-4">
            <strong>Sistema Aguardando Migra√ß√£o</strong><br>
            <small>Execute flask db upgrade para visualizar hist√≥rico</small>
        </td>
    </tr>
</tbody>
```

**üîß CORRE√á√ÉO NECESS√ÅRIA:**
```python
# ‚úÖ IMPLEMENTAR CARREGAMENTO REAL
@carteira_bp.route('/justificar-faturamento-parcial')
def justificar_faturamento_parcial():
    # ‚ùå FALTANDO: Buscar justificativas salvas
    justificativas = FaturamentoParcialJustificativa.query.order_by(
        FaturamentoParcialJustificativa.criado_em.desc()
    ).limit(50).all()
    
    return render_template('carteira/justificar_faturamento_parcial.html',
                         justificativas=justificativas)
```

---

## ‚ö†Ô∏è **PEND√äNCIAS M√âDIAS - M√âDIA PRIORIDADE**

### **6. üîß SINCRONIZA√á√ÉO CARTEIRA C√ìPIA INCOMPLETA**

**üîç PROBLEMAS IDENTIFICADOS:**

#### **6.1 Falta Hist√≥rico de Altera√ß√µes**
```python
# ‚ùå AUSENTE - NECESS√ÅRIO CRIAR
class HistoricoCarteiraCopia(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    num_pedido = db.Column(db.String(50), nullable=False)
    cod_produto = db.Column(db.String(50), nullable=False) 
    operacao = db.Column(db.String(20), nullable=False)  # BAIXA, ESTORNO, AJUSTE
    qtd_anterior = db.Column(db.Numeric(15,3))
    qtd_nova = db.Column(db.Numeric(15,3))
    motivo = db.Column(db.String(200))
    numero_nf = db.Column(db.String(20))
    criado_em = db.Column(db.DateTime, default=agora_brasil)
    criado_por = db.Column(db.String(100))
```

#### **6.2 Sem Revers√£o de Baixas**
```python
# ‚ùå FUN√á√ÉO N√ÉO EXISTE - NECESS√ÅRIA
def reverter_baixa_nf(numero_nf, motivo, usuario):
    """Reverte baixa quando NF √© cancelada"""
    # Buscar hist√≥rico da NF
    # Restaurar quantidades na carteira
    # Gerar estorno no estoque
    # Registrar auditoria
    pass
```

#### **6.3 Detec√ß√£o de Inconsist√™ncias Limitada**
```python
# ‚ùå FUN√á√ÉO IMPLEMENTADA MAS INCOMPLETA
def _detectar_inconsistencias_automaticas():
    # ‚úÖ Detecta diferen√ßas de saldo
    # ‚ùå N√ÉO detecta: NFs √≥rf√£s, produtos inexistentes, quantidades negativas
    # ‚ùå N√ÉO resolve: inconsist√™ncias automaticamente
    pass
```

---

### **7. üìä DASHBOARDS OPERACIONAIS FALTANTES**

**üîç DASHBOARDS NECESS√ÅRIOS:**

#### **7.1 Dashboard Principal de Standby**
```
‚ùå N√ÉO EXISTE - NECESS√ÅRIO:
- Resumo de saldos por tipo (AGUARDA_COMPLEMENTO, AGUARDA_DECISAO, etc.)
- Alertas por vencimento (hoje, 3 dias, 7 dias)
- A√ß√µes r√°pidas (aprovar, descartar, prorrogar)
- Gr√°ficos de tend√™ncia
```

#### **7.2 Dashboard de Inconsist√™ncias**
```
‚ùå PARCIALMENTE EXISTE - MELHORAR:
- Rota /carteira/inconsistencias existe
- ‚ùå Sem filtros por tipo, idade, valor
- ‚ùå Sem a√ß√µes em lote
- ‚ùå Sem prioriza√ß√£o autom√°tica
```

#### **7.3 Dashboard de Configura√ß√µes de Carga**
```
‚ùå N√ÉO EXISTE - NECESS√ÅRIO:
- Lista todas as cargas e tipos configurados
- Permite alterar configura√ß√µes em lote
- Mostra utiliza√ß√£o vs capacidade
- Alertas de cargas pr√≥ximas do limite
```

---

### **8. üîÑ L√ìGICA PARCIAL vs TOTAL INCOMPLETA**

**üîç PROBLEMA IDENTIFICADO:**
```python
# ‚ùå FUN√á√ÉO IMPLEMENTADA MAS SEM L√ìGICA REAL
def _processar_alteracao_inteligente(carteira_item_id, separacao_lote_id, qtd_nova, usuario):
    # ‚úÖ Estrutura existe
    # ‚ùå L√≥gica de decis√£o n√£o implementada
    # ‚ùå Cria√ß√£o de nova carga n√£o funciona
    # ‚ùå Preserva√ß√£o de dados operacionais n√£o implementada
    pass
```

**üîß IMPLEMENTA√á√ÉO NECESS√ÅRIA:**
```python
# ‚úÖ L√ìGICA REAL NECESS√ÅRIA
def decidir_alteracao_carga(tipo_carga, peso_atual, peso_novo):
    if tipo_carga.tipo_envio == 'PARCIAL':
        return 'CRIAR_NOVA_CARGA'
    
    if peso_novo > tipo_carga.capacidade_maxima_peso:
        return 'CRIAR_NOVA_CARGA'
    
    utilizacao = (peso_novo / tipo_carga.capacidade_maxima_peso) * 100
    if utilizacao > 95:  # 95% do limite
        return 'CRIAR_NOVA_CARGA'
    
    return 'ADICIONAR_CARGA_ATUAL'
```

---

## üîç **PEND√äNCIAS BAIXAS - MELHORIAS FUTURAS**

### **9. üì± Interface de Usu√°rio**

**üîß MELHORIAS NECESS√ÅRIAS:**
- **Filtros avan√ßados** nos dashboards
- **Ordena√ß√£o** por m√∫ltiplos campos
- **Exporta√ß√£o** de relat√≥rios
- **Interface mobile** responsiva
- **Notifica√ß√µes push** em tempo real

### **10. üîê Auditoria e Seguran√ßa**

**üîß IMPLEMENTA√á√ïES NECESS√ÅRIAS:**
- **Log completo** de todas as opera√ß√µes
- **Controle de permiss√µes** por funcionalidade
- **Backup autom√°tico** antes de altera√ß√µes cr√≠ticas
- **Valida√ß√µes** de integridade referencial

### **11. ‚ö° Performance e Otimiza√ß√£o**

**üîß OTIMIZA√á√ïES NECESS√ÅRIAS:**
- **√çndices** nas consultas principais
- **Cache** para c√°lculos complexos
- **Pagina√ß√£o** em listagens grandes
- **Jobs ass√≠ncronos** para processamentos pesados

---

## üìã **ROADMAP DE IMPLEMENTA√á√ÉO**

### **üö® FASE 1 - CR√çTICAS (1-2 semanas)**
1. ‚úÖ Corrigir Fun√ß√£o 1 (usar FaturamentoProduto)
2. ‚úÖ Implementar baixa autom√°tica de estoque
3. ‚úÖ Criar dashboard saldos standby funcional
4. ‚úÖ Implementar hist√≥rico de justificativas

### **‚ö†Ô∏è FASE 2 - IMPORTANTES (2-3 semanas)**
1. ‚úÖ Sistema de alertas autom√°ticos
2. ‚úÖ Configura√ß√µes completas de tipo carga
3. ‚úÖ L√≥gica PARCIAL vs TOTAL real
4. ‚úÖ Revers√£o de baixas (cancelamento NF)

### **üîß FASE 3 - MELHORIAS (3-4 semanas)**
1. ‚úÖ Dashboards operacionais completos
2. ‚úÖ Auditoria completa
3. ‚úÖ Otimiza√ß√µes de performance
4. ‚úÖ Interface mobile

---

## üéØ **CONCLUS√ÉO**

**üìä SITUA√á√ÉO ATUAL:**
- **Estrutura:** 80% implementada
- **Funcionalidades:** 40% funcionais
- **Integra√ß√µes:** 20% completas
- **Operacional:** 30% pronto para uso

**üöÄ PR√ìXIMOS PASSOS:**
1. **Priorizar** corre√ß√µes cr√≠ticas (Fase 1)
2. **Testar** cada corre√ß√£o isoladamente
3. **Integrar** com sistemas existentes
4. **Validar** com usu√°rios finais

**‚è±Ô∏è PRAZO ESTIMADO TOTAL:** 6-9 semanas para sistema 100% funcional

---

**üìù OBSERVA√á√ïES:**
- Este documento ser√° atualizado conforme implementa√ß√µes
- Cada pend√™ncia ser√° marcada como ‚úÖ quando resolvida
- Novas pend√™ncias podem ser adicionadas durante desenvolvimento 