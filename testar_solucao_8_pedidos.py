#!/usr/bin/env python3
"""
Teste da Solu√ß√£o dos 8 Pedidos Problem√°ticos
============================================

Script para testar se a corre√ß√£o resolve completamente os problemas identificados.

TESTES REALIZADOS:
1. Verifica NFs √≥rf√£s antes da corre√ß√£o
2. Executa a corre√ß√£o
3. Valida que n√£o h√° mais NFs √≥rf√£s  
4. Verifica EmbarqueItems sem erro_validacao
5. Simula sincroniza√ß√£o para verificar que n√£o gera mais alertas falsos

Autor: Sistema de Fretes
Data: 2025-08-13
"""

import logging
import sys
import os
from datetime import datetime

# Configurar path
sys.path.append(os.path.join(os.path.dirname(__file__)))

from app import create_app, db
from app.faturamento.models import RelatorioFaturamentoImportado, FaturamentoProduto
from app.estoque.models import MovimentacaoEstoque
from app.embarques.models import EmbarqueItem, Embarque
from app.pedidos.models import Pedido
from app.separacao.models import Separacao
from sqlalchemy import and_, text
from corrigir_nfs_problema_8_pedidos import CorretorNFsProblema

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('teste_solucao_8_pedidos.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

class TestadorSolucao:
    """
    Testa se a solu√ß√£o resolve completamente os problemas
    """
    
    def __init__(self):
        self.app = create_app()
        self.resultados_teste = {
            'pre_correcao': {},
            'pos_correcao': {},
            'validacao_final': {},
            'sucesso_geral': False
        }
    
    def executar_teste_completo(self):
        """
        Executa bateria completa de testes
        """
        with self.app.app_context():
            try:
                logger.info("üß™ INICIANDO TESTE COMPLETO DA SOLU√á√ÉO")
                logger.info("=" * 60)
                
                # FASE 1: Diagn√≥stico pr√©-corre√ß√£o
                self._diagnostico_pre_correcao()
                
                # FASE 2: Executar corre√ß√£o
                self._executar_correcao()
                
                # FASE 3: Valida√ß√£o p√≥s-corre√ß√£o  
                self._validacao_pos_correcao()
                
                # FASE 4: Teste de integra√ß√£o (simular sync)
                self._teste_integracao()
                
                # FASE 5: Resultado final
                self._avaliar_resultado_final()
                
                return self.resultados_teste
                
            except Exception as e:
                logger.error(f"‚ùå ERRO CR√çTICO no teste: {e}")
                self.resultados_teste['erro_critico'] = str(e)
                return self.resultados_teste
    
    def _diagnostico_pre_correcao(self):
        """
        Diagn√≥stica problemas antes da corre√ß√£o
        """
        logger.info("üîç FASE 1: DIAGN√ìSTICO PR√â-CORRE√á√ÉO")
        logger.info("-" * 40)
        
        # 1. Contar NFs √≥rf√£s
        query_nfs_orfas = """
        SELECT COUNT(*) as total,
               ARRAY_AGG(rfi.numero_nf ORDER BY rfi.numero_nf) as nfs
        FROM relatorio_faturamento_importado rfi
        INNER JOIN faturamento_produto fp ON rfi.numero_nf = fp.numero_nf
        WHERE rfi.ativo = true
        AND NOT EXISTS (
            SELECT 1 FROM movimentacao_estoque me 
            WHERE me.observacao LIKE '%NF ' || rfi.numero_nf || '%'
            AND me.tipo_movimentacao = 'FATURAMENTO'
        )
        """
        
        resultado = db.session.execute(text(query_nfs_orfas)).fetchone()
        nfs_orfas_count = resultado[0] if resultado else 0
        nfs_orfas_lista = resultado[1] if resultado and resultado[1] else []
        
        # 2. Contar EmbarqueItems com erro
        embarque_items_erro = EmbarqueItem.query.filter(
            EmbarqueItem.erro_validacao.isnot(None)
        ).count()
        
        # 3. Contar separa√ß√µes que poderiam gerar alertas falsos
        separacoes_risco = db.session.query(Separacao).join(
            Pedido, Separacao.separacao_lote_id == Pedido.separacao_lote_id
        ).filter(
            Pedido.status == 'COTADO'
        ).count()
        
        self.resultados_teste['pre_correcao'] = {
            'nfs_orfas': nfs_orfas_count,
            'nfs_orfas_lista': nfs_orfas_lista[:10],  # Mostrar apenas primeiras 10
            'embarque_items_erro': embarque_items_erro,
            'separacoes_risco_alerta': separacoes_risco
        }
        
        logger.info(f"üìä NFs √≥rf√£s encontradas: {nfs_orfas_count}")
        if nfs_orfas_lista:
            logger.info(f"üìã Exemplos: {nfs_orfas_lista[:5]}")
        logger.info(f"üìä EmbarqueItems com erro: {embarque_items_erro}")
        logger.info(f"üìä Separa√ß√µes COTADAS (risco alerta): {separacoes_risco}")
    
    def _executar_correcao(self):
        """
        Executa a corre√ß√£o usando o CorretorNFsProblema
        """
        logger.info("üîß FASE 2: EXECUTANDO CORRE√á√ÉO")
        logger.info("-" * 40)
        
        try:
            corretor = CorretorNFsProblema()
            resultado_correcao = corretor.executar_correcao_completa()
            
            self.resultados_teste['correcao_executada'] = resultado_correcao
            
            logger.info("‚úÖ Corre√ß√£o executada com sucesso")
            logger.info(f"üìä Problemas corrigidos: {resultado_correcao.get('problemas_corrigidos', 0)}")
            
        except Exception as e:
            logger.error(f"‚ùå Erro na corre√ß√£o: {e}")
            self.resultados_teste['erro_correcao'] = str(e)
            raise e
    
    def _validacao_pos_correcao(self):
        """
        Valida se os problemas foram resolvidos
        """
        logger.info("‚úÖ FASE 3: VALIDA√á√ÉO P√ìS-CORRE√á√ÉO")
        logger.info("-" * 40)
        
        # 1. Re-verificar NFs √≥rf√£s
        query_nfs_orfas = """
        SELECT COUNT(*) as total
        FROM relatorio_faturamento_importado rfi
        INNER JOIN faturamento_produto fp ON rfi.numero_nf = fp.numero_nf
        WHERE rfi.ativo = true
        AND NOT EXISTS (
            SELECT 1 FROM movimentacao_estoque me 
            WHERE me.observacao LIKE '%NF ' || rfi.numero_nf || '%'
            AND me.tipo_movimentacao = 'FATURAMENTO'
        )
        """
        
        resultado = db.session.execute(text(query_nfs_orfas)).fetchone()
        nfs_orfas_pos = resultado[0] if resultado else 0
        
        # 2. Re-verificar EmbarqueItems com erro
        embarque_items_erro_pos = EmbarqueItem.query.filter(
            EmbarqueItem.erro_validacao.isnot(None)
        ).count()
        
        # 3. Verificar MovimentacaoEstoque criadas
        movimentacoes_correcao = MovimentacaoEstoque.query.filter(
            MovimentacaoEstoque.criado_por == 'Corre√ß√£o Autom√°tica'
        ).count()
        
        self.resultados_teste['pos_correcao'] = {
            'nfs_orfas_restantes': nfs_orfas_pos,
            'embarque_items_erro_restantes': embarque_items_erro_pos,
            'movimentacoes_criadas_correcao': movimentacoes_correcao,
            'problema_nfs_resolvido': nfs_orfas_pos == 0,
            'problema_embarque_melhorou': embarque_items_erro_pos < self.resultados_teste['pre_correcao']['embarque_items_erro']
        }
        
        logger.info(f"üìä NFs √≥rf√£s restantes: {nfs_orfas_pos}")
        logger.info(f"üìä EmbarqueItems com erro restantes: {embarque_items_erro_pos}")
        logger.info(f"üìä Movimenta√ß√µes criadas pela corre√ß√£o: {movimentacoes_correcao}")
        
        if nfs_orfas_pos == 0:
            logger.info("‚úÖ SUCESSO: Problema de NFs √≥rf√£s resolvido!")
        else:
            logger.warning(f"‚ö†Ô∏è ATEN√á√ÉO: Ainda restam {nfs_orfas_pos} NFs √≥rf√£s")
    
    def _teste_integracao(self):
        """
        Testa se a sincroniza√ß√£o n√£o gerar√° mais alertas falsos
        """
        logger.info("üîÑ FASE 4: TESTE DE INTEGRA√á√ÉO")
        logger.info("-" * 40)
        
        # Simular as condi√ß√µes que causaram o problema original
        try:
            # 1. Verificar se ainda h√° separa√ß√µes COTADAS que poderiam gerar alertas
            separacoes_cotadas = db.session.query(Separacao).join(
                Pedido, Separacao.separacao_lote_id == Pedido.separacao_lote_id
            ).filter(
                Pedido.status == 'COTADO'
            ).all()
            
            problemas_potenciais = 0
            
            for sep in separacoes_cotadas[:10]:  # Testar apenas primeiras 10
                # Verificar se tem MovimentacaoEstoque correspondente
                tem_movimentacao = MovimentacaoEstoque.query.filter(
                    and_(
                        MovimentacaoEstoque.observacao.like(f'%lote separa√ß√£o {sep.separacao_lote_id}%'),
                        MovimentacaoEstoque.tipo_movimentacao == 'FATURAMENTO'
                    )
                ).first()
                
                if not tem_movimentacao:
                    problemas_potenciais += 1
            
            self.resultados_teste['integracao'] = {
                'separacoes_cotadas_testadas': min(len(separacoes_cotadas), 10),
                'problemas_potenciais': problemas_potenciais,
                'risco_alertas_falsos': problemas_potenciais > 0
            }
            
            logger.info(f"üìä Separa√ß√µes COTADAS testadas: {min(len(separacoes_cotadas), 10)}")
            logger.info(f"üìä Problemas potenciais encontrados: {problemas_potenciais}")
            
            if problemas_potenciais == 0:
                logger.info("‚úÖ SUCESSO: Risco de alertas falsos eliminado!")
            else:
                logger.warning(f"‚ö†Ô∏è ATEN√á√ÉO: {problemas_potenciais} separa√ß√µes ainda podem gerar alertas falsos")
        
        except Exception as e:
            logger.error(f"‚ùå Erro no teste de integra√ß√£o: {e}")
            self.resultados_teste['erro_integracao'] = str(e)
    
    def _avaliar_resultado_final(self):
        """
        Avalia o resultado final do teste
        """
        logger.info("üéØ FASE 5: AVALIA√á√ÉO FINAL")
        logger.info("-" * 40)
        
        pre = self.resultados_teste['pre_correcao']
        pos = self.resultados_teste['pos_correcao']
        integracao = self.resultados_teste.get('integracao', {})
        
        # Crit√©rios de sucesso
        criterios = {
            'nfs_orfas_resolvidas': pos.get('nfs_orfas_restantes', 999) == 0,
            'embarque_items_melhoraram': pos.get('problema_embarque_melhorou', False),
            'movimentacoes_criadas': pos.get('movimentacoes_criadas_correcao', 0) > 0,
            'risco_alertas_eliminado': not integracao.get('risco_alertas_falsos', True)
        }
        
        sucessos = sum(criterios.values())
        total_criterios = len(criterios)
        
        self.resultados_teste['validacao_final'] = {
            'criterios_atendidos': criterios,
            'sucessos': sucessos,
            'total_criterios': total_criterios,
            'percentual_sucesso': (sucessos / total_criterios) * 100,
            'aprovado': sucessos >= total_criterios - 1  # Permite 1 crit√©rio n√£o atendido
        }
        
        self.resultados_teste['sucesso_geral'] = sucessos >= total_criterios - 1
        
        logger.info(f"üìä Crit√©rios atendidos: {sucessos}/{total_criterios}")
        logger.info(f"üìä Percentual de sucesso: {(sucessos/total_criterios)*100:.1f}%")
        
        for criterio, atendido in criterios.items():
            status = "‚úÖ" if atendido else "‚ùå"
            logger.info(f"  {status} {criterio}")
        
        if self.resultados_teste['sucesso_geral']:
            logger.info("üéâ TESTE APROVADO: Solu√ß√£o resolve os problemas!")
        else:
            logger.warning("‚ö†Ô∏è TESTE REPROVADO: Solu√ß√£o precisa de ajustes")
    
    def gerar_relatorio_teste(self):
        """
        Gera relat√≥rio detalhado do teste
        """
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        relatorio = f"""
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
RELAT√ìRIO DE TESTE - SOLU√á√ÉO DOS 8 PEDIDOS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üïê Data/Hora: {timestamp}
üéØ Objetivo: Validar corre√ß√£o dos problemas de NFs √≥rf√£s

üìä RESULTADOS PR√â-CORRE√á√ÉO:
‚Ä¢ NFs √≥rf√£s: {self.resultados_teste['pre_correcao'].get('nfs_orfas', 0)}
‚Ä¢ EmbarqueItems com erro: {self.resultados_teste['pre_correcao'].get('embarque_items_erro', 0)}
‚Ä¢ Separa√ß√µes COTADAS (risco): {self.resultados_teste['pre_correcao'].get('separacoes_risco_alerta', 0)}

üìä RESULTADOS P√ìS-CORRE√á√ÉO:
‚Ä¢ NFs √≥rf√£s restantes: {self.resultados_teste['pos_correcao'].get('nfs_orfas_restantes', 'N/A')}
‚Ä¢ EmbarqueItems com erro restantes: {self.resultados_teste['pos_correcao'].get('embarque_items_erro_restantes', 'N/A')}
‚Ä¢ Movimenta√ß√µes criadas: {self.resultados_teste['pos_correcao'].get('movimentacoes_criadas_correcao', 'N/A')}

üîÑ TESTE DE INTEGRA√á√ÉO:
‚Ä¢ Problemas potenciais: {self.resultados_teste.get('integracao', {}).get('problemas_potenciais', 'N/A')}
‚Ä¢ Risco de alertas falsos: {self.resultados_teste.get('integracao', {}).get('risco_alertas_falsos', 'N/A')}

‚úÖ AVALIA√á√ÉO FINAL:
‚Ä¢ Percentual de sucesso: {self.resultados_teste['validacao_final'].get('percentual_sucesso', 0):.1f}%
‚Ä¢ Resultado: {'APROVADO' if self.resultados_teste['sucesso_geral'] else 'REPROVADO'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
"""
        
        return relatorio


def main():
    """
    Fun√ß√£o principal
    """
    try:
        print("üß™ INICIANDO TESTE DA SOLU√á√ÉO DOS 8 PEDIDOS")
        print("=" * 50)
        
        testador = TestadorSolucao()
        resultado = testador.executar_teste_completo()
        
        # Gerar relat√≥rio
        relatorio = testador.gerar_relatorio_teste()
        
        # Salvar relat√≥rio
        with open('relatorio_teste_solucao.txt', 'w', encoding='utf-8') as f:
            f.write(relatorio)
        
        print("\n" + relatorio)
        print(f"üìÑ Relat√≥rio salvo em: relatorio_teste_solucao.txt")
        print(f"üìÑ Log detalhado em: teste_solucao_8_pedidos.log")
        
        return resultado['sucesso_geral']
        
    except Exception as e:
        print(f"\n‚ùå ERRO CR√çTICO: {e}")
        return False


if __name__ == "__main__":
    sucesso = main()
    sys.exit(0 if sucesso else 1)